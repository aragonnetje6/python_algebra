Help on module math_tree:

NAME
    math_tree - basic expression tree with evaluation and derivation

CLASSES
    builtins.Exception(builtins.BaseException)
        EvaluationError
    builtins.object
        Node
            ArbitraryOperator
                ArbitraryLogicalOperator
                    And
                    Or
                    Xor
                ComparisonOperator
                    GreaterEqual
                    GreaterThan
                    IsEqual
                    LessEqual
                    LessThan
                Modulus
                Product
                Sum
            BinaryOperator
                Exponent
                Logarithm
            Derivative
            Piecewise
            Term
                Constant
                    Boolean
                    Complex
                    E
                    Integer
                    Pi
                    Rational
                    Real
                Variable
            UnaryOperator
                Absolute
                ArcCosine
                ArcSine
                ArcTangent
                Ceiling
                Cosine
                Factorial
                Floor
                Invert
                Negate
                Not
                Sine
                Tangent
    
    class Absolute(UnaryOperator)
     |  Absolute(child: 'Node') -> 'None'
     |  
     |  Absolute operator node
     |  
     |  Method resolution order:
     |      Absolute
     |      UnaryOperator
     |      Node
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  derivative(self, variable: 'str') -> 'Node'
     |      returns an expression tree representing the (partial) derivative to the passed variable of this tree
     |  
     |  evaluate(self, var_dict: 'Optional[Variables]' = None) -> 'ConstantType'
     |      Evaluates the expression tree using the values from var_dict, returns int or float
     |  
     |  mathml(self) -> 'str'
     |      returns the MathML representation of the tree
     |  
     |  simplify(self, var_dict: 'Optional[Variables]' = None) -> 'Node'
     |      returns a simplified version of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  symbol = 'abs'
     |  
     |  wolfram_func = 'Abs'
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from UnaryOperator:
     |  
     |  __init__(self, child: 'Node') -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  dependencies(self) -> 'set[str]'
     |      returns set of all variables present in the tree
     |  
     |  infix(self) -> 'str'
     |      returns infix representation of the tree
     |  
     |  list_nodes(self) -> 'list[Node]'
     |      returns a list of all nodes in the tree
     |  
     |  substitute(self, var: 'str', sub: 'Node') -> 'Node'
     |      substitute a variable with an expression inside this tree, returns the resulting tree
     |  
     |  wolfram(self) -> 'str'
     |      return wolfram language representation of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from UnaryOperator:
     |  
     |  child
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Node:
     |  
     |  __add__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __and__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __bool__(self) -> 'bool'
     |  
     |  __complex__(self) -> 'complex'
     |  
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  __float__(self) -> 'float'
     |  
     |  __ge__(self, other: 'Any') -> 'bool'
     |      Return self>=value.
     |  
     |  __gt__(self, other: 'Any') -> 'bool'
     |      Return self>value.
     |  
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |  
     |  __int__(self) -> 'int'
     |  
     |  __invert__(self) -> 'Not'
     |  
     |  __le__(self, other: 'Any') -> 'bool'
     |      Return self<=value.
     |  
     |  __lt__(self, other: 'Any') -> 'bool'
     |      Return self<value.
     |  
     |  __mul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ne__(self, other: 'Any') -> 'bool'
     |      Return self!=value.
     |  
     |  __neg__(self) -> 'Negate'
     |  
     |  __or__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __pow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __radd__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __rand__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __rmul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ror__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __rpow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __rsub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rtruediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rxor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  __setattr__(self, key: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  __sub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __truediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __xor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  display(self) -> 'None'
     |      shows graphical representation of expression
     |  
     |  total_derivative(self) -> 'Node'
     |      returns an expression tree representing the total derivative of this tree.
     |      the total derivative of f is defined as sum(f.derivative(var) for var in f.dependencies)
    
    class And(ArbitraryLogicalOperator)
     |  And(*args: 'Node') -> 'None'
     |  
     |  logical AND operator node
     |  
     |  Method resolution order:
     |      And
     |      ArbitraryLogicalOperator
     |      ArbitraryOperator
     |      Node
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  symbol = '&'
     |  
     |  wolfram_func = 'And'
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ArbitraryLogicalOperator:
     |  
     |  derivative(self, variable: 'str') -> 'Node'
     |      returns an expression tree representing the (partial) derivative to the passed variable of this tree
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ArbitraryOperator:
     |  
     |  __init__(self, *args: 'Node') -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  dependencies(self) -> 'set[str]'
     |      returns set of all variables present in the tree
     |  
     |  evaluate(self, var_dict: 'Optional[Variables]' = None) -> 'ConstantType'
     |      Evaluates the expression tree using the values from var_dict, returns int or float
     |  
     |  infix(self) -> 'str'
     |      returns infix representation of the tree
     |  
     |  list_nodes(self) -> 'list[Node]'
     |      returns a list of all nodes in the tree
     |  
     |  mathml(self) -> 'str'
     |      returns the MathML representation of the tree
     |  
     |  simplify(self, var_dict: 'Optional[Variables]' = None) -> 'Node'
     |      returns a simplified version of the tree
     |  
     |  substitute(self, var: 'str', sub: 'Node') -> 'Node'
     |      substitute a variable with an expression inside this tree, returns the resulting tree
     |  
     |  wolfram(self) -> 'str'
     |      return wolfram language representation of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ArbitraryOperator:
     |  
     |  children
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Node:
     |  
     |  __add__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __and__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __bool__(self) -> 'bool'
     |  
     |  __complex__(self) -> 'complex'
     |  
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  __float__(self) -> 'float'
     |  
     |  __ge__(self, other: 'Any') -> 'bool'
     |      Return self>=value.
     |  
     |  __gt__(self, other: 'Any') -> 'bool'
     |      Return self>value.
     |  
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |  
     |  __int__(self) -> 'int'
     |  
     |  __invert__(self) -> 'Not'
     |  
     |  __le__(self, other: 'Any') -> 'bool'
     |      Return self<=value.
     |  
     |  __lt__(self, other: 'Any') -> 'bool'
     |      Return self<value.
     |  
     |  __mul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ne__(self, other: 'Any') -> 'bool'
     |      Return self!=value.
     |  
     |  __neg__(self) -> 'Negate'
     |  
     |  __or__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __pow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __radd__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __rand__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __rmul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ror__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __rpow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __rsub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rtruediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rxor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  __setattr__(self, key: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  __sub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __truediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __xor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  display(self) -> 'None'
     |      shows graphical representation of expression
     |  
     |  total_derivative(self) -> 'Node'
     |      returns an expression tree representing the total derivative of this tree.
     |      the total derivative of f is defined as sum(f.derivative(var) for var in f.dependencies)
    
    class ArbitraryLogicalOperator(ArbitraryOperator)
     |  ArbitraryLogicalOperator(*args: 'Node') -> 'None'
     |  
     |  Abstract base class for comparison operators
     |  
     |  Method resolution order:
     |      ArbitraryLogicalOperator
     |      ArbitraryOperator
     |      Node
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  derivative(self, variable: 'str') -> 'Node'
     |      returns an expression tree representing the (partial) derivative to the passed variable of this tree
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset({'_eval_func', '_simplify', 'wolfram_f...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ArbitraryOperator:
     |  
     |  __init__(self, *args: 'Node') -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  dependencies(self) -> 'set[str]'
     |      returns set of all variables present in the tree
     |  
     |  evaluate(self, var_dict: 'Optional[Variables]' = None) -> 'ConstantType'
     |      Evaluates the expression tree using the values from var_dict, returns int or float
     |  
     |  infix(self) -> 'str'
     |      returns infix representation of the tree
     |  
     |  list_nodes(self) -> 'list[Node]'
     |      returns a list of all nodes in the tree
     |  
     |  mathml(self) -> 'str'
     |      returns the MathML representation of the tree
     |  
     |  simplify(self, var_dict: 'Optional[Variables]' = None) -> 'Node'
     |      returns a simplified version of the tree
     |  
     |  substitute(self, var: 'str', sub: 'Node') -> 'Node'
     |      substitute a variable with an expression inside this tree, returns the resulting tree
     |  
     |  wolfram(self) -> 'str'
     |      return wolfram language representation of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from ArbitraryOperator:
     |  
     |  wolfram_func
     |      abstract property, returns function name for wolfram language
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ArbitraryOperator:
     |  
     |  children
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from ArbitraryOperator:
     |  
     |  symbol = ''
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Node:
     |  
     |  __add__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __and__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __bool__(self) -> 'bool'
     |  
     |  __complex__(self) -> 'complex'
     |  
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  __float__(self) -> 'float'
     |  
     |  __ge__(self, other: 'Any') -> 'bool'
     |      Return self>=value.
     |  
     |  __gt__(self, other: 'Any') -> 'bool'
     |      Return self>value.
     |  
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |  
     |  __int__(self) -> 'int'
     |  
     |  __invert__(self) -> 'Not'
     |  
     |  __le__(self, other: 'Any') -> 'bool'
     |      Return self<=value.
     |  
     |  __lt__(self, other: 'Any') -> 'bool'
     |      Return self<value.
     |  
     |  __mul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ne__(self, other: 'Any') -> 'bool'
     |      Return self!=value.
     |  
     |  __neg__(self) -> 'Negate'
     |  
     |  __or__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __pow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __radd__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __rand__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __rmul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ror__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __rpow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __rsub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rtruediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rxor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  __setattr__(self, key: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  __sub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __truediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __xor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  display(self) -> 'None'
     |      shows graphical representation of expression
     |  
     |  total_derivative(self) -> 'Node'
     |      returns an expression tree representing the total derivative of this tree.
     |      the total derivative of f is defined as sum(f.derivative(var) for var in f.dependencies)
    
    class ArbitraryOperator(Node)
     |  ArbitraryOperator(*args: 'Node') -> 'None'
     |  
     |  Abstract Base Class for multi-input operator in expression tree
     |  
     |  Method resolution order:
     |      ArbitraryOperator
     |      Node
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, *args: 'Node') -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  dependencies(self) -> 'set[str]'
     |      returns set of all variables present in the tree
     |  
     |  evaluate(self, var_dict: 'Optional[Variables]' = None) -> 'ConstantType'
     |      Evaluates the expression tree using the values from var_dict, returns int or float
     |  
     |  infix(self) -> 'str'
     |      returns infix representation of the tree
     |  
     |  list_nodes(self) -> 'list[Node]'
     |      returns a list of all nodes in the tree
     |  
     |  mathml(self) -> 'str'
     |      returns the MathML representation of the tree
     |  
     |  simplify(self, var_dict: 'Optional[Variables]' = None) -> 'Node'
     |      returns a simplified version of the tree
     |  
     |  substitute(self, var: 'str', sub: 'Node') -> 'Node'
     |      substitute a variable with an expression inside this tree, returns the resulting tree
     |  
     |  wolfram(self) -> 'str'
     |      return wolfram language representation of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |  
     |  wolfram_func
     |      abstract property, returns function name for wolfram language
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  children
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset({'_eval_func', '_simplify', 'derivativ...
     |  
     |  symbol = ''
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Node:
     |  
     |  __add__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __and__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __bool__(self) -> 'bool'
     |  
     |  __complex__(self) -> 'complex'
     |  
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  __float__(self) -> 'float'
     |  
     |  __ge__(self, other: 'Any') -> 'bool'
     |      Return self>=value.
     |  
     |  __gt__(self, other: 'Any') -> 'bool'
     |      Return self>value.
     |  
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |  
     |  __int__(self) -> 'int'
     |  
     |  __invert__(self) -> 'Not'
     |  
     |  __le__(self, other: 'Any') -> 'bool'
     |      Return self<=value.
     |  
     |  __lt__(self, other: 'Any') -> 'bool'
     |      Return self<value.
     |  
     |  __mul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ne__(self, other: 'Any') -> 'bool'
     |      Return self!=value.
     |  
     |  __neg__(self) -> 'Negate'
     |  
     |  __or__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __pow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __radd__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __rand__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __rmul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ror__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __rpow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __rsub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rtruediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rxor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  __setattr__(self, key: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  __sub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __truediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __xor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  derivative(self, variable: 'str') -> 'Node'
     |      returns an expression tree representing the (partial) derivative to the passed variable of this tree
     |  
     |  display(self) -> 'None'
     |      shows graphical representation of expression
     |  
     |  total_derivative(self) -> 'Node'
     |      returns an expression tree representing the total derivative of this tree.
     |      the total derivative of f is defined as sum(f.derivative(var) for var in f.dependencies)
    
    class ArcCosine(UnaryOperator)
     |  ArcCosine(child: 'Node') -> 'None'
     |  
     |  Arccosine operator node in radians
     |  
     |  Method resolution order:
     |      ArcCosine
     |      UnaryOperator
     |      Node
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  derivative(self, variable: 'str') -> 'Node'
     |      returns an expression tree representing the (partial) derivative to the passed variable of this tree
     |  
     |  evaluate(self, var_dict: 'Optional[Variables]' = None) -> 'ConstantType'
     |      Evaluates the expression tree using the values from var_dict, returns int or float
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  symbol = 'acos'
     |  
     |  wolfram_func = 'ArcCos'
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from UnaryOperator:
     |  
     |  __init__(self, child: 'Node') -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  dependencies(self) -> 'set[str]'
     |      returns set of all variables present in the tree
     |  
     |  infix(self) -> 'str'
     |      returns infix representation of the tree
     |  
     |  list_nodes(self) -> 'list[Node]'
     |      returns a list of all nodes in the tree
     |  
     |  mathml(self) -> 'str'
     |      returns the MathML representation of the tree
     |  
     |  simplify(self, var_dict: 'Optional[Variables]' = None) -> 'Node'
     |      returns a simplified version of the tree
     |  
     |  substitute(self, var: 'str', sub: 'Node') -> 'Node'
     |      substitute a variable with an expression inside this tree, returns the resulting tree
     |  
     |  wolfram(self) -> 'str'
     |      return wolfram language representation of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from UnaryOperator:
     |  
     |  child
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Node:
     |  
     |  __add__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __and__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __bool__(self) -> 'bool'
     |  
     |  __complex__(self) -> 'complex'
     |  
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  __float__(self) -> 'float'
     |  
     |  __ge__(self, other: 'Any') -> 'bool'
     |      Return self>=value.
     |  
     |  __gt__(self, other: 'Any') -> 'bool'
     |      Return self>value.
     |  
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |  
     |  __int__(self) -> 'int'
     |  
     |  __invert__(self) -> 'Not'
     |  
     |  __le__(self, other: 'Any') -> 'bool'
     |      Return self<=value.
     |  
     |  __lt__(self, other: 'Any') -> 'bool'
     |      Return self<value.
     |  
     |  __mul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ne__(self, other: 'Any') -> 'bool'
     |      Return self!=value.
     |  
     |  __neg__(self) -> 'Negate'
     |  
     |  __or__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __pow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __radd__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __rand__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __rmul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ror__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __rpow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __rsub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rtruediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rxor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  __setattr__(self, key: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  __sub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __truediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __xor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  display(self) -> 'None'
     |      shows graphical representation of expression
     |  
     |  total_derivative(self) -> 'Node'
     |      returns an expression tree representing the total derivative of this tree.
     |      the total derivative of f is defined as sum(f.derivative(var) for var in f.dependencies)
    
    class ArcSine(UnaryOperator)
     |  ArcSine(child: 'Node') -> 'None'
     |  
     |  Arcsine operator node in radians
     |  
     |  Method resolution order:
     |      ArcSine
     |      UnaryOperator
     |      Node
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  derivative(self, variable: 'str') -> 'Node'
     |      returns an expression tree representing the (partial) derivative to the passed variable of this tree
     |  
     |  evaluate(self, var_dict: 'Optional[Variables]' = None) -> 'ConstantType'
     |      Evaluates the expression tree using the values from var_dict, returns int or float
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  symbol = 'asin'
     |  
     |  wolfram_func = 'ArcSin'
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from UnaryOperator:
     |  
     |  __init__(self, child: 'Node') -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  dependencies(self) -> 'set[str]'
     |      returns set of all variables present in the tree
     |  
     |  infix(self) -> 'str'
     |      returns infix representation of the tree
     |  
     |  list_nodes(self) -> 'list[Node]'
     |      returns a list of all nodes in the tree
     |  
     |  mathml(self) -> 'str'
     |      returns the MathML representation of the tree
     |  
     |  simplify(self, var_dict: 'Optional[Variables]' = None) -> 'Node'
     |      returns a simplified version of the tree
     |  
     |  substitute(self, var: 'str', sub: 'Node') -> 'Node'
     |      substitute a variable with an expression inside this tree, returns the resulting tree
     |  
     |  wolfram(self) -> 'str'
     |      return wolfram language representation of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from UnaryOperator:
     |  
     |  child
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Node:
     |  
     |  __add__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __and__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __bool__(self) -> 'bool'
     |  
     |  __complex__(self) -> 'complex'
     |  
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  __float__(self) -> 'float'
     |  
     |  __ge__(self, other: 'Any') -> 'bool'
     |      Return self>=value.
     |  
     |  __gt__(self, other: 'Any') -> 'bool'
     |      Return self>value.
     |  
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |  
     |  __int__(self) -> 'int'
     |  
     |  __invert__(self) -> 'Not'
     |  
     |  __le__(self, other: 'Any') -> 'bool'
     |      Return self<=value.
     |  
     |  __lt__(self, other: 'Any') -> 'bool'
     |      Return self<value.
     |  
     |  __mul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ne__(self, other: 'Any') -> 'bool'
     |      Return self!=value.
     |  
     |  __neg__(self) -> 'Negate'
     |  
     |  __or__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __pow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __radd__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __rand__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __rmul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ror__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __rpow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __rsub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rtruediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rxor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  __setattr__(self, key: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  __sub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __truediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __xor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  display(self) -> 'None'
     |      shows graphical representation of expression
     |  
     |  total_derivative(self) -> 'Node'
     |      returns an expression tree representing the total derivative of this tree.
     |      the total derivative of f is defined as sum(f.derivative(var) for var in f.dependencies)
    
    class ArcTangent(UnaryOperator)
     |  ArcTangent(child: 'Node') -> 'None'
     |  
     |  Arctangent operator node in radians
     |  
     |  Method resolution order:
     |      ArcTangent
     |      UnaryOperator
     |      Node
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  derivative(self, variable: 'str') -> 'Node'
     |      returns an expression tree representing the (partial) derivative to the passed variable of this tree
     |  
     |  evaluate(self, var_dict: 'Optional[Variables]' = None) -> 'ConstantType'
     |      Evaluates the expression tree using the values from var_dict, returns int or float
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  symbol = 'atan'
     |  
     |  wolfram_func = 'ArcTan'
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from UnaryOperator:
     |  
     |  __init__(self, child: 'Node') -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  dependencies(self) -> 'set[str]'
     |      returns set of all variables present in the tree
     |  
     |  infix(self) -> 'str'
     |      returns infix representation of the tree
     |  
     |  list_nodes(self) -> 'list[Node]'
     |      returns a list of all nodes in the tree
     |  
     |  mathml(self) -> 'str'
     |      returns the MathML representation of the tree
     |  
     |  simplify(self, var_dict: 'Optional[Variables]' = None) -> 'Node'
     |      returns a simplified version of the tree
     |  
     |  substitute(self, var: 'str', sub: 'Node') -> 'Node'
     |      substitute a variable with an expression inside this tree, returns the resulting tree
     |  
     |  wolfram(self) -> 'str'
     |      return wolfram language representation of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from UnaryOperator:
     |  
     |  child
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Node:
     |  
     |  __add__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __and__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __bool__(self) -> 'bool'
     |  
     |  __complex__(self) -> 'complex'
     |  
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  __float__(self) -> 'float'
     |  
     |  __ge__(self, other: 'Any') -> 'bool'
     |      Return self>=value.
     |  
     |  __gt__(self, other: 'Any') -> 'bool'
     |      Return self>value.
     |  
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |  
     |  __int__(self) -> 'int'
     |  
     |  __invert__(self) -> 'Not'
     |  
     |  __le__(self, other: 'Any') -> 'bool'
     |      Return self<=value.
     |  
     |  __lt__(self, other: 'Any') -> 'bool'
     |      Return self<value.
     |  
     |  __mul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ne__(self, other: 'Any') -> 'bool'
     |      Return self!=value.
     |  
     |  __neg__(self) -> 'Negate'
     |  
     |  __or__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __pow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __radd__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __rand__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __rmul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ror__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __rpow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __rsub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rtruediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rxor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  __setattr__(self, key: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  __sub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __truediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __xor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  display(self) -> 'None'
     |      shows graphical representation of expression
     |  
     |  total_derivative(self) -> 'Node'
     |      returns an expression tree representing the total derivative of this tree.
     |      the total derivative of f is defined as sum(f.derivative(var) for var in f.dependencies)
    
    class BinaryOperator(Node)
     |  BinaryOperator(child1: 'Node', child2: 'Node') -> 'None'
     |  
     |  Abstract Base Class for 2-input operator in expression tree
     |  
     |  Method resolution order:
     |      BinaryOperator
     |      Node
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, child1: 'Node', child2: 'Node') -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  list_nodes(self) -> 'list[Node]'
     |      return a list of all nodes in the tree
     |  
     |  substitute(self, var: 'str', sub: 'Node') -> 'Node'
     |      substitute a variable with an expression inside this tree, returns the resulting tree
     |  
     |  wolfram(self) -> 'str'
     |      return wolfram language representation of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  child1
     |  
     |  child2
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset({'derivative', 'evaluate', 'infix', 'm...
     |  
     |  wolfram_func = ''
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Node:
     |  
     |  __add__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __and__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __bool__(self) -> 'bool'
     |  
     |  __complex__(self) -> 'complex'
     |  
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  __float__(self) -> 'float'
     |  
     |  __ge__(self, other: 'Any') -> 'bool'
     |      Return self>=value.
     |  
     |  __gt__(self, other: 'Any') -> 'bool'
     |      Return self>value.
     |  
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |  
     |  __int__(self) -> 'int'
     |  
     |  __invert__(self) -> 'Not'
     |  
     |  __le__(self, other: 'Any') -> 'bool'
     |      Return self<=value.
     |  
     |  __lt__(self, other: 'Any') -> 'bool'
     |      Return self<value.
     |  
     |  __mul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ne__(self, other: 'Any') -> 'bool'
     |      Return self!=value.
     |  
     |  __neg__(self) -> 'Negate'
     |  
     |  __or__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __pow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __radd__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __rand__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __rmul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ror__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __rpow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __rsub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rtruediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rxor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  __setattr__(self, key: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  __sub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __truediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __xor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  dependencies(self) -> 'set[str]'
     |      returns set of all variables present in the tree
     |  
     |  derivative(self, variable: 'str') -> 'Node'
     |      returns an expression tree representing the (partial) derivative to the passed variable of this tree
     |  
     |  display(self) -> 'None'
     |      shows graphical representation of expression
     |  
     |  evaluate(self, var_dict: 'Optional[Variables]' = None) -> 'ConstantType'
     |      Evaluates the expression tree using the values from var_dict, returns int or float
     |  
     |  infix(self) -> 'str'
     |      returns infix representation of the tree
     |  
     |  mathml(self) -> 'str'
     |      returns the MathML representation of the tree
     |  
     |  simplify(self, var_dict: 'Optional[Variables]' = None) -> 'Node'
     |      returns a simplified version of the tree
     |  
     |  total_derivative(self) -> 'Node'
     |      returns an expression tree representing the total derivative of this tree.
     |      the total derivative of f is defined as sum(f.derivative(var) for var in f.dependencies)
    
    class Boolean(Constant)
     |  Boolean(value: 'bool') -> 'None'
     |  
     |  real number in expression tree
     |  
     |  Method resolution order:
     |      Boolean
     |      Constant
     |      Term
     |      Node
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, value: 'bool') -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  evaluate(self, var_dict: 'Optional[Variables]' = None) -> 'ConstantType'
     |      Evaluates the expression tree using the values from var_dict, returns int or float
     |  
     |  infix(self) -> 'str'
     |      returns infix representation of the tree
     |  
     |  mathml(self) -> 'str'
     |      returns the MathML representation of the tree
     |  
     |  simplify(self, var_dict: 'Optional[Variables]' = None) -> 'Node'
     |      returns a simplified version of the tree
     |  
     |  wolfram(self) -> 'str'
     |      return wolfram language representation of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  value
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Constant:
     |  
     |  derivative(self, variable: 'str') -> 'Node'
     |      returns an expression tree representing the (partial) derivative to the passed variable of this tree
     |  
     |  substitute(self, var: 'str', sub: 'Node') -> 'Node'
     |      substitute a variable with an expression inside this tree, returns the resulting tree
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Term:
     |  
     |  list_nodes(self) -> 'list[Node]'
     |      returns a list of all nodes in the tree
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Node:
     |  
     |  __add__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __and__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __bool__(self) -> 'bool'
     |  
     |  __complex__(self) -> 'complex'
     |  
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  __float__(self) -> 'float'
     |  
     |  __ge__(self, other: 'Any') -> 'bool'
     |      Return self>=value.
     |  
     |  __gt__(self, other: 'Any') -> 'bool'
     |      Return self>value.
     |  
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |  
     |  __int__(self) -> 'int'
     |  
     |  __invert__(self) -> 'Not'
     |  
     |  __le__(self, other: 'Any') -> 'bool'
     |      Return self<=value.
     |  
     |  __lt__(self, other: 'Any') -> 'bool'
     |      Return self<value.
     |  
     |  __mul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ne__(self, other: 'Any') -> 'bool'
     |      Return self!=value.
     |  
     |  __neg__(self) -> 'Negate'
     |  
     |  __or__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __pow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __radd__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __rand__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __rmul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ror__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __rpow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __rsub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rtruediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rxor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  __setattr__(self, key: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  __sub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __truediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __xor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  dependencies(self) -> 'set[str]'
     |      returns set of all variables present in the tree
     |  
     |  display(self) -> 'None'
     |      shows graphical representation of expression
     |  
     |  total_derivative(self) -> 'Node'
     |      returns an expression tree representing the total derivative of this tree.
     |      the total derivative of f is defined as sum(f.derivative(var) for var in f.dependencies)
    
    class Ceiling(UnaryOperator)
     |  Ceiling(child: 'Node') -> 'None'
     |  
     |  ceiling operator
     |  
     |  Method resolution order:
     |      Ceiling
     |      UnaryOperator
     |      Node
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  derivative(self, variable: 'str') -> 'Node'
     |      returns an expression tree representing the (partial) derivative to the passed variable of this tree
     |  
     |  evaluate(self, var_dict: 'Optional[Variables]' = None) -> 'ConstantType'
     |      Evaluates the expression tree using the values from var_dict, returns int or float
     |  
     |  mathml(self) -> 'str'
     |      returns the MathML representation of the tree
     |  
     |  simplify(self, var_dict: 'Optional[Variables]' = None) -> 'Node'
     |      returns a simplified version of the tree
     |  
     |  wolfram(self) -> 'str'
     |      return wolfram language representation of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  symbol = 'ceil'
     |  
     |  wolfram_func = 'Ceiling'
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from UnaryOperator:
     |  
     |  __init__(self, child: 'Node') -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  dependencies(self) -> 'set[str]'
     |      returns set of all variables present in the tree
     |  
     |  infix(self) -> 'str'
     |      returns infix representation of the tree
     |  
     |  list_nodes(self) -> 'list[Node]'
     |      returns a list of all nodes in the tree
     |  
     |  substitute(self, var: 'str', sub: 'Node') -> 'Node'
     |      substitute a variable with an expression inside this tree, returns the resulting tree
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from UnaryOperator:
     |  
     |  child
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Node:
     |  
     |  __add__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __and__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __bool__(self) -> 'bool'
     |  
     |  __complex__(self) -> 'complex'
     |  
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  __float__(self) -> 'float'
     |  
     |  __ge__(self, other: 'Any') -> 'bool'
     |      Return self>=value.
     |  
     |  __gt__(self, other: 'Any') -> 'bool'
     |      Return self>value.
     |  
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |  
     |  __int__(self) -> 'int'
     |  
     |  __invert__(self) -> 'Not'
     |  
     |  __le__(self, other: 'Any') -> 'bool'
     |      Return self<=value.
     |  
     |  __lt__(self, other: 'Any') -> 'bool'
     |      Return self<value.
     |  
     |  __mul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ne__(self, other: 'Any') -> 'bool'
     |      Return self!=value.
     |  
     |  __neg__(self) -> 'Negate'
     |  
     |  __or__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __pow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __radd__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __rand__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __rmul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ror__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __rpow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __rsub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rtruediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rxor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  __setattr__(self, key: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  __sub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __truediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __xor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  display(self) -> 'None'
     |      shows graphical representation of expression
     |  
     |  total_derivative(self) -> 'Node'
     |      returns an expression tree representing the total derivative of this tree.
     |      the total derivative of f is defined as sum(f.derivative(var) for var in f.dependencies)
    
    class ComparisonOperator(ArbitraryOperator)
     |  ComparisonOperator(*args: 'Node') -> 'None'
     |  
     |  Abstract base class for comparison operators
     |  
     |  Method resolution order:
     |      ComparisonOperator
     |      ArbitraryOperator
     |      Node
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  derivative(self, variable: 'str') -> 'Node'
     |      returns an expression tree representing the (partial) derivative to the passed variable of this tree
     |  
     |  evaluate(self, var_dict: 'Optional[Variables]' = None) -> 'bool'
     |      Evaluates the expression tree using the values from var_dict, returns int or float
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset({'_eval_func', 'wolfram_func'})
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ArbitraryOperator:
     |  
     |  __init__(self, *args: 'Node') -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  dependencies(self) -> 'set[str]'
     |      returns set of all variables present in the tree
     |  
     |  infix(self) -> 'str'
     |      returns infix representation of the tree
     |  
     |  list_nodes(self) -> 'list[Node]'
     |      returns a list of all nodes in the tree
     |  
     |  mathml(self) -> 'str'
     |      returns the MathML representation of the tree
     |  
     |  simplify(self, var_dict: 'Optional[Variables]' = None) -> 'Node'
     |      returns a simplified version of the tree
     |  
     |  substitute(self, var: 'str', sub: 'Node') -> 'Node'
     |      substitute a variable with an expression inside this tree, returns the resulting tree
     |  
     |  wolfram(self) -> 'str'
     |      return wolfram language representation of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from ArbitraryOperator:
     |  
     |  wolfram_func
     |      abstract property, returns function name for wolfram language
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ArbitraryOperator:
     |  
     |  children
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from ArbitraryOperator:
     |  
     |  symbol = ''
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Node:
     |  
     |  __add__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __and__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __bool__(self) -> 'bool'
     |  
     |  __complex__(self) -> 'complex'
     |  
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  __float__(self) -> 'float'
     |  
     |  __ge__(self, other: 'Any') -> 'bool'
     |      Return self>=value.
     |  
     |  __gt__(self, other: 'Any') -> 'bool'
     |      Return self>value.
     |  
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |  
     |  __int__(self) -> 'int'
     |  
     |  __invert__(self) -> 'Not'
     |  
     |  __le__(self, other: 'Any') -> 'bool'
     |      Return self<=value.
     |  
     |  __lt__(self, other: 'Any') -> 'bool'
     |      Return self<value.
     |  
     |  __mul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ne__(self, other: 'Any') -> 'bool'
     |      Return self!=value.
     |  
     |  __neg__(self) -> 'Negate'
     |  
     |  __or__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __pow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __radd__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __rand__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __rmul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ror__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __rpow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __rsub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rtruediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rxor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  __setattr__(self, key: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  __sub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __truediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __xor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  display(self) -> 'None'
     |      shows graphical representation of expression
     |  
     |  total_derivative(self) -> 'Node'
     |      returns an expression tree representing the total derivative of this tree.
     |      the total derivative of f is defined as sum(f.derivative(var) for var in f.dependencies)
    
    class Complex(Constant)
     |  Complex(value: 'complex') -> 'None'
     |  
     |  real number in expression tree
     |  
     |  Method resolution order:
     |      Complex
     |      Constant
     |      Term
     |      Node
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, value: 'complex') -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  evaluate(self, var_dict: 'Optional[Variables]' = None) -> 'complex'
     |      Evaluates the expression tree using the values from var_dict, returns int or float
     |  
     |  infix(self) -> 'str'
     |      returns infix representation of the tree
     |  
     |  mathml(self) -> 'str'
     |      returns the MathML representation of the tree
     |  
     |  wolfram(self) -> 'str'
     |      return wolfram language representation of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  value
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Constant:
     |  
     |  derivative(self, variable: 'str') -> 'Node'
     |      returns an expression tree representing the (partial) derivative to the passed variable of this tree
     |  
     |  simplify(self, var_dict: 'Optional[Variables]' = None) -> 'Node'
     |      returns a simplified version of the tree
     |  
     |  substitute(self, var: 'str', sub: 'Node') -> 'Node'
     |      substitute a variable with an expression inside this tree, returns the resulting tree
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Term:
     |  
     |  list_nodes(self) -> 'list[Node]'
     |      returns a list of all nodes in the tree
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Node:
     |  
     |  __add__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __and__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __bool__(self) -> 'bool'
     |  
     |  __complex__(self) -> 'complex'
     |  
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  __float__(self) -> 'float'
     |  
     |  __ge__(self, other: 'Any') -> 'bool'
     |      Return self>=value.
     |  
     |  __gt__(self, other: 'Any') -> 'bool'
     |      Return self>value.
     |  
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |  
     |  __int__(self) -> 'int'
     |  
     |  __invert__(self) -> 'Not'
     |  
     |  __le__(self, other: 'Any') -> 'bool'
     |      Return self<=value.
     |  
     |  __lt__(self, other: 'Any') -> 'bool'
     |      Return self<value.
     |  
     |  __mul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ne__(self, other: 'Any') -> 'bool'
     |      Return self!=value.
     |  
     |  __neg__(self) -> 'Negate'
     |  
     |  __or__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __pow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __radd__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __rand__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __rmul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ror__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __rpow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __rsub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rtruediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rxor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  __setattr__(self, key: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  __sub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __truediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __xor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  dependencies(self) -> 'set[str]'
     |      returns set of all variables present in the tree
     |  
     |  display(self) -> 'None'
     |      shows graphical representation of expression
     |  
     |  total_derivative(self) -> 'Node'
     |      returns an expression tree representing the total derivative of this tree.
     |      the total derivative of f is defined as sum(f.derivative(var) for var in f.dependencies)
    
    class Constant(Term)
     |  Constant() -> 'None'
     |  
     |  constant term in expression tree
     |  
     |  Method resolution order:
     |      Constant
     |      Term
     |      Node
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  derivative(self, variable: 'str') -> 'Node'
     |      returns an expression tree representing the (partial) derivative to the passed variable of this tree
     |  
     |  simplify(self, var_dict: 'Optional[Variables]' = None) -> 'Node'
     |      returns a simplified version of the tree
     |  
     |  substitute(self, var: 'str', sub: 'Node') -> 'Node'
     |      substitute a variable with an expression inside this tree, returns the resulting tree
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset({'__repr__', 'evaluate', 'infix', 'mat...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Term:
     |  
     |  list_nodes(self) -> 'list[Node]'
     |      returns a list of all nodes in the tree
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Node:
     |  
     |  __add__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __and__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __bool__(self) -> 'bool'
     |  
     |  __complex__(self) -> 'complex'
     |  
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  __float__(self) -> 'float'
     |  
     |  __ge__(self, other: 'Any') -> 'bool'
     |      Return self>=value.
     |  
     |  __gt__(self, other: 'Any') -> 'bool'
     |      Return self>value.
     |  
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |  
     |  __init__(self) -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __int__(self) -> 'int'
     |  
     |  __invert__(self) -> 'Not'
     |  
     |  __le__(self, other: 'Any') -> 'bool'
     |      Return self<=value.
     |  
     |  __lt__(self, other: 'Any') -> 'bool'
     |      Return self<value.
     |  
     |  __mul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ne__(self, other: 'Any') -> 'bool'
     |      Return self!=value.
     |  
     |  __neg__(self) -> 'Negate'
     |  
     |  __or__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __pow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __radd__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __rand__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  __rmul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ror__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __rpow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __rsub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rtruediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rxor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  __setattr__(self, key: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  __sub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __truediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __xor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  dependencies(self) -> 'set[str]'
     |      returns set of all variables present in the tree
     |  
     |  display(self) -> 'None'
     |      shows graphical representation of expression
     |  
     |  evaluate(self, var_dict: 'Optional[Variables]' = None) -> 'ConstantType'
     |      Evaluates the expression tree using the values from var_dict, returns int or float
     |  
     |  infix(self) -> 'str'
     |      returns infix representation of the tree
     |  
     |  mathml(self) -> 'str'
     |      returns the MathML representation of the tree
     |  
     |  total_derivative(self) -> 'Node'
     |      returns an expression tree representing the total derivative of this tree.
     |      the total derivative of f is defined as sum(f.derivative(var) for var in f.dependencies)
     |  
     |  wolfram(self) -> 'str'
     |      return wolfram language representation of the tree
    
    class Cosine(UnaryOperator)
     |  Cosine(child: 'Node') -> 'None'
     |  
     |  Cosine operator node in radians
     |  
     |  Method resolution order:
     |      Cosine
     |      UnaryOperator
     |      Node
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  derivative(self, variable: 'str') -> 'Node'
     |      returns an expression tree representing the (partial) derivative to the passed variable of this tree
     |  
     |  evaluate(self, var_dict: 'Optional[Variables]' = None) -> 'ConstantType'
     |      Evaluates the expression tree using the values from var_dict, returns int or float
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  symbol = 'cos'
     |  
     |  wolfram_func = 'Cos'
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from UnaryOperator:
     |  
     |  __init__(self, child: 'Node') -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  dependencies(self) -> 'set[str]'
     |      returns set of all variables present in the tree
     |  
     |  infix(self) -> 'str'
     |      returns infix representation of the tree
     |  
     |  list_nodes(self) -> 'list[Node]'
     |      returns a list of all nodes in the tree
     |  
     |  mathml(self) -> 'str'
     |      returns the MathML representation of the tree
     |  
     |  simplify(self, var_dict: 'Optional[Variables]' = None) -> 'Node'
     |      returns a simplified version of the tree
     |  
     |  substitute(self, var: 'str', sub: 'Node') -> 'Node'
     |      substitute a variable with an expression inside this tree, returns the resulting tree
     |  
     |  wolfram(self) -> 'str'
     |      return wolfram language representation of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from UnaryOperator:
     |  
     |  child
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Node:
     |  
     |  __add__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __and__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __bool__(self) -> 'bool'
     |  
     |  __complex__(self) -> 'complex'
     |  
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  __float__(self) -> 'float'
     |  
     |  __ge__(self, other: 'Any') -> 'bool'
     |      Return self>=value.
     |  
     |  __gt__(self, other: 'Any') -> 'bool'
     |      Return self>value.
     |  
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |  
     |  __int__(self) -> 'int'
     |  
     |  __invert__(self) -> 'Not'
     |  
     |  __le__(self, other: 'Any') -> 'bool'
     |      Return self<=value.
     |  
     |  __lt__(self, other: 'Any') -> 'bool'
     |      Return self<value.
     |  
     |  __mul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ne__(self, other: 'Any') -> 'bool'
     |      Return self!=value.
     |  
     |  __neg__(self) -> 'Negate'
     |  
     |  __or__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __pow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __radd__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __rand__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __rmul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ror__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __rpow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __rsub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rtruediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rxor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  __setattr__(self, key: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  __sub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __truediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __xor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  display(self) -> 'None'
     |      shows graphical representation of expression
     |  
     |  total_derivative(self) -> 'Node'
     |      returns an expression tree representing the total derivative of this tree.
     |      the total derivative of f is defined as sum(f.derivative(var) for var in f.dependencies)
    
    class Derivative(Node)
     |  Derivative(expression: 'Node', variable: 'str') -> 'None'
     |  
     |  Derivative operation node
     |  
     |  Method resolution order:
     |      Derivative
     |      Node
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, expression: 'Node', variable: 'str') -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  dependencies(self) -> 'set[str]'
     |      returns set of all variables present in the tree
     |  
     |  derivative(self, variable: 'str') -> 'Node'
     |      returns an expression tree representing the (partial) derivative to the passed variable of this tree
     |  
     |  evaluate(self, var_dict: 'Optional[Variables]' = None) -> 'ConstantType'
     |      Evaluates the expression tree using the values from var_dict, returns int or float
     |  
     |  infix(self) -> 'str'
     |      returns infix representation of the tree
     |  
     |  list_nodes(self) -> 'list[Node]'
     |      returns a list of all nodes in the tree
     |  
     |  mathml(self) -> 'str'
     |      returns the MathML representation of the tree
     |  
     |  simplify(self, var_dict: 'Optional[Variables]' = None) -> 'Node'
     |      returns a simplified version of the tree
     |  
     |  substitute(self, var: 'str', sub: 'Node') -> 'Node'
     |      substitute a variable with an expression inside this tree, returns the resulting tree
     |  
     |  wolfram(self) -> 'str'
     |      return wolfram language representation of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  child
     |  
     |  variable
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  symbol = ''
     |  
     |  wolfram_func = 'D'
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Node:
     |  
     |  __add__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __and__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __bool__(self) -> 'bool'
     |  
     |  __complex__(self) -> 'complex'
     |  
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  __float__(self) -> 'float'
     |  
     |  __ge__(self, other: 'Any') -> 'bool'
     |      Return self>=value.
     |  
     |  __gt__(self, other: 'Any') -> 'bool'
     |      Return self>value.
     |  
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |  
     |  __int__(self) -> 'int'
     |  
     |  __invert__(self) -> 'Not'
     |  
     |  __le__(self, other: 'Any') -> 'bool'
     |      Return self<=value.
     |  
     |  __lt__(self, other: 'Any') -> 'bool'
     |      Return self<value.
     |  
     |  __mul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ne__(self, other: 'Any') -> 'bool'
     |      Return self!=value.
     |  
     |  __neg__(self) -> 'Negate'
     |  
     |  __or__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __pow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __radd__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __rand__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __rmul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ror__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __rpow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __rsub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rtruediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rxor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  __setattr__(self, key: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  __sub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __truediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __xor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  display(self) -> 'None'
     |      shows graphical representation of expression
     |  
     |  total_derivative(self) -> 'Node'
     |      returns an expression tree representing the total derivative of this tree.
     |      the total derivative of f is defined as sum(f.derivative(var) for var in f.dependencies)
    
    class E(Constant)
     |  E() -> 'None'
     |  
     |  mathematical constant in expression tree
     |  
     |  Method resolution order:
     |      E
     |      Constant
     |      Term
     |      Node
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self) -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  evaluate(self, var_dict: 'Optional[Variables]' = None) -> 'ConstantType'
     |      Evaluates the expression tree using the values from var_dict, returns int or float
     |  
     |  infix(self) -> 'str'
     |      returns infix representation of the tree
     |  
     |  mathml(self) -> 'str'
     |      returns the MathML representation of the tree
     |  
     |  simplify(self, var_dict: 'Optional[Variables]' = None) -> 'Node'
     |      returns a simplified version of the tree
     |  
     |  wolfram(self) -> 'str'
     |      return wolfram language representation of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  value
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Constant:
     |  
     |  derivative(self, variable: 'str') -> 'Node'
     |      returns an expression tree representing the (partial) derivative to the passed variable of this tree
     |  
     |  substitute(self, var: 'str', sub: 'Node') -> 'Node'
     |      substitute a variable with an expression inside this tree, returns the resulting tree
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Term:
     |  
     |  list_nodes(self) -> 'list[Node]'
     |      returns a list of all nodes in the tree
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Node:
     |  
     |  __add__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __and__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __bool__(self) -> 'bool'
     |  
     |  __complex__(self) -> 'complex'
     |  
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  __float__(self) -> 'float'
     |  
     |  __ge__(self, other: 'Any') -> 'bool'
     |      Return self>=value.
     |  
     |  __gt__(self, other: 'Any') -> 'bool'
     |      Return self>value.
     |  
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |  
     |  __int__(self) -> 'int'
     |  
     |  __invert__(self) -> 'Not'
     |  
     |  __le__(self, other: 'Any') -> 'bool'
     |      Return self<=value.
     |  
     |  __lt__(self, other: 'Any') -> 'bool'
     |      Return self<value.
     |  
     |  __mul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ne__(self, other: 'Any') -> 'bool'
     |      Return self!=value.
     |  
     |  __neg__(self) -> 'Negate'
     |  
     |  __or__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __pow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __radd__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __rand__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __rmul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ror__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __rpow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __rsub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rtruediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rxor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  __setattr__(self, key: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  __sub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __truediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __xor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  dependencies(self) -> 'set[str]'
     |      returns set of all variables present in the tree
     |  
     |  display(self) -> 'None'
     |      shows graphical representation of expression
     |  
     |  total_derivative(self) -> 'Node'
     |      returns an expression tree representing the total derivative of this tree.
     |      the total derivative of f is defined as sum(f.derivative(var) for var in f.dependencies)
    
    class EvaluationError(builtins.Exception)
     |  Error raised if evaluation goes badly
     |  
     |  Method resolution order:
     |      EvaluationError
     |      builtins.Exception
     |      builtins.BaseException
     |      builtins.object
     |  
     |  Data descriptors defined here:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.Exception:
     |  
     |  __init__(self, /, *args, **kwargs)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.Exception:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.BaseException:
     |  
     |  __delattr__(self, name, /)
     |      Implement delattr(self, name).
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __reduce__(...)
     |      Helper for pickle.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __setattr__(self, name, value, /)
     |      Implement setattr(self, name, value).
     |  
     |  __setstate__(...)
     |  
     |  __str__(self, /)
     |      Return str(self).
     |  
     |  with_traceback(...)
     |      Exception.with_traceback(tb) --
     |      set self.__traceback__ to tb and return self.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from builtins.BaseException:
     |  
     |  __cause__
     |      exception cause
     |  
     |  __context__
     |      exception context
     |  
     |  __dict__
     |  
     |  __suppress_context__
     |  
     |  __traceback__
     |  
     |  args
    
    class Exponent(BinaryOperator)
     |  Exponent(child1: 'Node', child2: 'Optional[Node]' = None)
     |  
     |  Exponent operator node
     |  
     |  Method resolution order:
     |      Exponent
     |      BinaryOperator
     |      Node
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, child1: 'Node', child2: 'Optional[Node]' = None)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  derivative(self, variable: 'str') -> 'Node'
     |      returns an expression tree representing the (partial) derivative to the passed variable of this tree
     |  
     |  evaluate(self, var_dict: 'Optional[Variables]' = None) -> 'ConstantType'
     |      Evaluate expression tree
     |  
     |  infix(self) -> 'str'
     |      returns infix representation of the tree
     |  
     |  mathml(self) -> 'str'
     |      returns the MathML representation of the tree
     |  
     |  simplify(self, var_dict: 'Optional[Variables]' = None) -> 'Node'
     |      returns a simplified version of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  symbol = '**'
     |  
     |  wolfram_func = 'Power'
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from BinaryOperator:
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  list_nodes(self) -> 'list[Node]'
     |      return a list of all nodes in the tree
     |  
     |  substitute(self, var: 'str', sub: 'Node') -> 'Node'
     |      substitute a variable with an expression inside this tree, returns the resulting tree
     |  
     |  wolfram(self) -> 'str'
     |      return wolfram language representation of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from BinaryOperator:
     |  
     |  child1
     |  
     |  child2
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Node:
     |  
     |  __add__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __and__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __bool__(self) -> 'bool'
     |  
     |  __complex__(self) -> 'complex'
     |  
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  __float__(self) -> 'float'
     |  
     |  __ge__(self, other: 'Any') -> 'bool'
     |      Return self>=value.
     |  
     |  __gt__(self, other: 'Any') -> 'bool'
     |      Return self>value.
     |  
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |  
     |  __int__(self) -> 'int'
     |  
     |  __invert__(self) -> 'Not'
     |  
     |  __le__(self, other: 'Any') -> 'bool'
     |      Return self<=value.
     |  
     |  __lt__(self, other: 'Any') -> 'bool'
     |      Return self<value.
     |  
     |  __mul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ne__(self, other: 'Any') -> 'bool'
     |      Return self!=value.
     |  
     |  __neg__(self) -> 'Negate'
     |  
     |  __or__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __pow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __radd__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __rand__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __rmul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ror__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __rpow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __rsub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rtruediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rxor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  __setattr__(self, key: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  __sub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __truediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __xor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  dependencies(self) -> 'set[str]'
     |      returns set of all variables present in the tree
     |  
     |  display(self) -> 'None'
     |      shows graphical representation of expression
     |  
     |  total_derivative(self) -> 'Node'
     |      returns an expression tree representing the total derivative of this tree.
     |      the total derivative of f is defined as sum(f.derivative(var) for var in f.dependencies)
    
    class Factorial(UnaryOperator)
     |  Factorial(child: 'Node') -> 'None'
     |  
     |  factorial operator
     |  
     |  Method resolution order:
     |      Factorial
     |      UnaryOperator
     |      Node
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  derivative(self, variable: 'str') -> 'Node'
     |      returns an expression tree representing the (partial) derivative to the passed variable of this tree
     |  
     |  evaluate(self, var_dict: 'Optional[Variables]' = None) -> 'ConstantType'
     |      Evaluates the expression tree using the values from var_dict, returns int or float
     |  
     |  infix(self) -> 'str'
     |      returns infix representation of the tree
     |  
     |  mathml(self) -> 'str'
     |      returns the MathML representation of the tree
     |  
     |  wolfram(self) -> 'str'
     |      return wolfram language representation of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  symbol = '!'
     |  
     |  wolfram_func = 'Factorial'
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from UnaryOperator:
     |  
     |  __init__(self, child: 'Node') -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  dependencies(self) -> 'set[str]'
     |      returns set of all variables present in the tree
     |  
     |  list_nodes(self) -> 'list[Node]'
     |      returns a list of all nodes in the tree
     |  
     |  simplify(self, var_dict: 'Optional[Variables]' = None) -> 'Node'
     |      returns a simplified version of the tree
     |  
     |  substitute(self, var: 'str', sub: 'Node') -> 'Node'
     |      substitute a variable with an expression inside this tree, returns the resulting tree
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from UnaryOperator:
     |  
     |  child
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Node:
     |  
     |  __add__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __and__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __bool__(self) -> 'bool'
     |  
     |  __complex__(self) -> 'complex'
     |  
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  __float__(self) -> 'float'
     |  
     |  __ge__(self, other: 'Any') -> 'bool'
     |      Return self>=value.
     |  
     |  __gt__(self, other: 'Any') -> 'bool'
     |      Return self>value.
     |  
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |  
     |  __int__(self) -> 'int'
     |  
     |  __invert__(self) -> 'Not'
     |  
     |  __le__(self, other: 'Any') -> 'bool'
     |      Return self<=value.
     |  
     |  __lt__(self, other: 'Any') -> 'bool'
     |      Return self<value.
     |  
     |  __mul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ne__(self, other: 'Any') -> 'bool'
     |      Return self!=value.
     |  
     |  __neg__(self) -> 'Negate'
     |  
     |  __or__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __pow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __radd__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __rand__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __rmul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ror__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __rpow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __rsub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rtruediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rxor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  __setattr__(self, key: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  __sub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __truediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __xor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  display(self) -> 'None'
     |      shows graphical representation of expression
     |  
     |  total_derivative(self) -> 'Node'
     |      returns an expression tree representing the total derivative of this tree.
     |      the total derivative of f is defined as sum(f.derivative(var) for var in f.dependencies)
    
    class Floor(UnaryOperator)
     |  Floor(child: 'Node') -> 'None'
     |  
     |  floor operator
     |  
     |  Method resolution order:
     |      Floor
     |      UnaryOperator
     |      Node
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  derivative(self, variable: 'str') -> 'Node'
     |      returns an expression tree representing the (partial) derivative to the passed variable of this tree
     |  
     |  evaluate(self, var_dict: 'Optional[Variables]' = None) -> 'ConstantType'
     |      Evaluates the expression tree using the values from var_dict, returns int or float
     |  
     |  mathml(self) -> 'str'
     |      returns the MathML representation of the tree
     |  
     |  simplify(self, var_dict: 'Optional[Variables]' = None) -> 'Node'
     |      returns a simplified version of the tree
     |  
     |  wolfram(self) -> 'str'
     |      return wolfram language representation of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  symbol = 'floor'
     |  
     |  wolfram_func = 'Floor'
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from UnaryOperator:
     |  
     |  __init__(self, child: 'Node') -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  dependencies(self) -> 'set[str]'
     |      returns set of all variables present in the tree
     |  
     |  infix(self) -> 'str'
     |      returns infix representation of the tree
     |  
     |  list_nodes(self) -> 'list[Node]'
     |      returns a list of all nodes in the tree
     |  
     |  substitute(self, var: 'str', sub: 'Node') -> 'Node'
     |      substitute a variable with an expression inside this tree, returns the resulting tree
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from UnaryOperator:
     |  
     |  child
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Node:
     |  
     |  __add__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __and__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __bool__(self) -> 'bool'
     |  
     |  __complex__(self) -> 'complex'
     |  
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  __float__(self) -> 'float'
     |  
     |  __ge__(self, other: 'Any') -> 'bool'
     |      Return self>=value.
     |  
     |  __gt__(self, other: 'Any') -> 'bool'
     |      Return self>value.
     |  
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |  
     |  __int__(self) -> 'int'
     |  
     |  __invert__(self) -> 'Not'
     |  
     |  __le__(self, other: 'Any') -> 'bool'
     |      Return self<=value.
     |  
     |  __lt__(self, other: 'Any') -> 'bool'
     |      Return self<value.
     |  
     |  __mul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ne__(self, other: 'Any') -> 'bool'
     |      Return self!=value.
     |  
     |  __neg__(self) -> 'Negate'
     |  
     |  __or__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __pow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __radd__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __rand__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __rmul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ror__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __rpow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __rsub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rtruediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rxor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  __setattr__(self, key: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  __sub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __truediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __xor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  display(self) -> 'None'
     |      shows graphical representation of expression
     |  
     |  total_derivative(self) -> 'Node'
     |      returns an expression tree representing the total derivative of this tree.
     |      the total derivative of f is defined as sum(f.derivative(var) for var in f.dependencies)
    
    class GreaterEqual(ComparisonOperator)
     |  GreaterEqual(*args: 'Node') -> 'None'
     |  
     |  Greater-equal operator node
     |  
     |  Method resolution order:
     |      GreaterEqual
     |      ComparisonOperator
     |      ArbitraryOperator
     |      Node
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  symbol = '>='
     |  
     |  wolfram_func = 'GreaterEqual'
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ComparisonOperator:
     |  
     |  derivative(self, variable: 'str') -> 'Node'
     |      returns an expression tree representing the (partial) derivative to the passed variable of this tree
     |  
     |  evaluate(self, var_dict: 'Optional[Variables]' = None) -> 'bool'
     |      Evaluates the expression tree using the values from var_dict, returns int or float
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ArbitraryOperator:
     |  
     |  __init__(self, *args: 'Node') -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  dependencies(self) -> 'set[str]'
     |      returns set of all variables present in the tree
     |  
     |  infix(self) -> 'str'
     |      returns infix representation of the tree
     |  
     |  list_nodes(self) -> 'list[Node]'
     |      returns a list of all nodes in the tree
     |  
     |  mathml(self) -> 'str'
     |      returns the MathML representation of the tree
     |  
     |  simplify(self, var_dict: 'Optional[Variables]' = None) -> 'Node'
     |      returns a simplified version of the tree
     |  
     |  substitute(self, var: 'str', sub: 'Node') -> 'Node'
     |      substitute a variable with an expression inside this tree, returns the resulting tree
     |  
     |  wolfram(self) -> 'str'
     |      return wolfram language representation of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ArbitraryOperator:
     |  
     |  children
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Node:
     |  
     |  __add__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __and__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __bool__(self) -> 'bool'
     |  
     |  __complex__(self) -> 'complex'
     |  
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  __float__(self) -> 'float'
     |  
     |  __ge__(self, other: 'Any') -> 'bool'
     |      Return self>=value.
     |  
     |  __gt__(self, other: 'Any') -> 'bool'
     |      Return self>value.
     |  
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |  
     |  __int__(self) -> 'int'
     |  
     |  __invert__(self) -> 'Not'
     |  
     |  __le__(self, other: 'Any') -> 'bool'
     |      Return self<=value.
     |  
     |  __lt__(self, other: 'Any') -> 'bool'
     |      Return self<value.
     |  
     |  __mul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ne__(self, other: 'Any') -> 'bool'
     |      Return self!=value.
     |  
     |  __neg__(self) -> 'Negate'
     |  
     |  __or__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __pow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __radd__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __rand__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __rmul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ror__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __rpow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __rsub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rtruediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rxor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  __setattr__(self, key: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  __sub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __truediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __xor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  display(self) -> 'None'
     |      shows graphical representation of expression
     |  
     |  total_derivative(self) -> 'Node'
     |      returns an expression tree representing the total derivative of this tree.
     |      the total derivative of f is defined as sum(f.derivative(var) for var in f.dependencies)
    
    class GreaterThan(ComparisonOperator)
     |  GreaterThan(*args: 'Node') -> 'None'
     |  
     |  Greater-than operator node
     |  
     |  Method resolution order:
     |      GreaterThan
     |      ComparisonOperator
     |      ArbitraryOperator
     |      Node
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  symbol = '>'
     |  
     |  wolfram_func = 'Greater'
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ComparisonOperator:
     |  
     |  derivative(self, variable: 'str') -> 'Node'
     |      returns an expression tree representing the (partial) derivative to the passed variable of this tree
     |  
     |  evaluate(self, var_dict: 'Optional[Variables]' = None) -> 'bool'
     |      Evaluates the expression tree using the values from var_dict, returns int or float
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ArbitraryOperator:
     |  
     |  __init__(self, *args: 'Node') -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  dependencies(self) -> 'set[str]'
     |      returns set of all variables present in the tree
     |  
     |  infix(self) -> 'str'
     |      returns infix representation of the tree
     |  
     |  list_nodes(self) -> 'list[Node]'
     |      returns a list of all nodes in the tree
     |  
     |  mathml(self) -> 'str'
     |      returns the MathML representation of the tree
     |  
     |  simplify(self, var_dict: 'Optional[Variables]' = None) -> 'Node'
     |      returns a simplified version of the tree
     |  
     |  substitute(self, var: 'str', sub: 'Node') -> 'Node'
     |      substitute a variable with an expression inside this tree, returns the resulting tree
     |  
     |  wolfram(self) -> 'str'
     |      return wolfram language representation of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ArbitraryOperator:
     |  
     |  children
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Node:
     |  
     |  __add__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __and__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __bool__(self) -> 'bool'
     |  
     |  __complex__(self) -> 'complex'
     |  
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  __float__(self) -> 'float'
     |  
     |  __ge__(self, other: 'Any') -> 'bool'
     |      Return self>=value.
     |  
     |  __gt__(self, other: 'Any') -> 'bool'
     |      Return self>value.
     |  
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |  
     |  __int__(self) -> 'int'
     |  
     |  __invert__(self) -> 'Not'
     |  
     |  __le__(self, other: 'Any') -> 'bool'
     |      Return self<=value.
     |  
     |  __lt__(self, other: 'Any') -> 'bool'
     |      Return self<value.
     |  
     |  __mul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ne__(self, other: 'Any') -> 'bool'
     |      Return self!=value.
     |  
     |  __neg__(self) -> 'Negate'
     |  
     |  __or__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __pow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __radd__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __rand__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __rmul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ror__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __rpow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __rsub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rtruediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rxor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  __setattr__(self, key: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  __sub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __truediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __xor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  display(self) -> 'None'
     |      shows graphical representation of expression
     |  
     |  total_derivative(self) -> 'Node'
     |      returns an expression tree representing the total derivative of this tree.
     |      the total derivative of f is defined as sum(f.derivative(var) for var in f.dependencies)
    
    class Integer(Constant)
     |  Integer(value: 'int') -> 'None'
     |  
     |  integer number in expression tree
     |  
     |  Method resolution order:
     |      Integer
     |      Constant
     |      Term
     |      Node
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, value: 'int') -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  evaluate(self, var_dict: 'Optional[Variables]' = None) -> 'int'
     |      Evaluates the expression tree using the values from var_dict, returns int or float
     |  
     |  infix(self) -> 'str'
     |      returns infix representation of the tree
     |  
     |  mathml(self) -> 'str'
     |      returns the MathML representation of the tree
     |  
     |  wolfram(self) -> 'str'
     |      return wolfram language representation of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  value
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Constant:
     |  
     |  derivative(self, variable: 'str') -> 'Node'
     |      returns an expression tree representing the (partial) derivative to the passed variable of this tree
     |  
     |  simplify(self, var_dict: 'Optional[Variables]' = None) -> 'Node'
     |      returns a simplified version of the tree
     |  
     |  substitute(self, var: 'str', sub: 'Node') -> 'Node'
     |      substitute a variable with an expression inside this tree, returns the resulting tree
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Term:
     |  
     |  list_nodes(self) -> 'list[Node]'
     |      returns a list of all nodes in the tree
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Node:
     |  
     |  __add__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __and__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __bool__(self) -> 'bool'
     |  
     |  __complex__(self) -> 'complex'
     |  
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  __float__(self) -> 'float'
     |  
     |  __ge__(self, other: 'Any') -> 'bool'
     |      Return self>=value.
     |  
     |  __gt__(self, other: 'Any') -> 'bool'
     |      Return self>value.
     |  
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |  
     |  __int__(self) -> 'int'
     |  
     |  __invert__(self) -> 'Not'
     |  
     |  __le__(self, other: 'Any') -> 'bool'
     |      Return self<=value.
     |  
     |  __lt__(self, other: 'Any') -> 'bool'
     |      Return self<value.
     |  
     |  __mul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ne__(self, other: 'Any') -> 'bool'
     |      Return self!=value.
     |  
     |  __neg__(self) -> 'Negate'
     |  
     |  __or__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __pow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __radd__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __rand__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __rmul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ror__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __rpow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __rsub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rtruediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rxor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  __setattr__(self, key: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  __sub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __truediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __xor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  dependencies(self) -> 'set[str]'
     |      returns set of all variables present in the tree
     |  
     |  display(self) -> 'None'
     |      shows graphical representation of expression
     |  
     |  total_derivative(self) -> 'Node'
     |      returns an expression tree representing the total derivative of this tree.
     |      the total derivative of f is defined as sum(f.derivative(var) for var in f.dependencies)
    
    class Invert(UnaryOperator)
     |  Invert(child: 'Node') -> 'None'
     |  
     |  Unary inversion operator
     |  
     |  Method resolution order:
     |      Invert
     |      UnaryOperator
     |      Node
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  derivative(self, variable: 'str') -> 'Node'
     |      returns an expression tree representing the (partial) derivative to the passed variable of this tree
     |  
     |  evaluate(self, var_dict: 'Optional[Variables]' = None) -> 'ConstantType'
     |      Evaluates the expression tree using the values from var_dict, returns int or float
     |  
     |  infix(self) -> 'str'
     |      returns infix representation of the tree
     |  
     |  mathml(self) -> 'str'
     |      returns the MathML representation of the tree
     |  
     |  simplify(self, var_dict: 'Optional[Variables]' = None) -> 'Node'
     |      returns a simplified version of the tree
     |  
     |  wolfram(self) -> 'str'
     |      return wolfram language representation of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  symbol = '1/'
     |  
     |  wolfram_func = 'Divide'
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from UnaryOperator:
     |  
     |  __init__(self, child: 'Node') -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  dependencies(self) -> 'set[str]'
     |      returns set of all variables present in the tree
     |  
     |  list_nodes(self) -> 'list[Node]'
     |      returns a list of all nodes in the tree
     |  
     |  substitute(self, var: 'str', sub: 'Node') -> 'Node'
     |      substitute a variable with an expression inside this tree, returns the resulting tree
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from UnaryOperator:
     |  
     |  child
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Node:
     |  
     |  __add__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __and__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __bool__(self) -> 'bool'
     |  
     |  __complex__(self) -> 'complex'
     |  
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  __float__(self) -> 'float'
     |  
     |  __ge__(self, other: 'Any') -> 'bool'
     |      Return self>=value.
     |  
     |  __gt__(self, other: 'Any') -> 'bool'
     |      Return self>value.
     |  
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |  
     |  __int__(self) -> 'int'
     |  
     |  __invert__(self) -> 'Not'
     |  
     |  __le__(self, other: 'Any') -> 'bool'
     |      Return self<=value.
     |  
     |  __lt__(self, other: 'Any') -> 'bool'
     |      Return self<value.
     |  
     |  __mul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ne__(self, other: 'Any') -> 'bool'
     |      Return self!=value.
     |  
     |  __neg__(self) -> 'Negate'
     |  
     |  __or__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __pow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __radd__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __rand__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __rmul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ror__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __rpow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __rsub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rtruediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rxor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  __setattr__(self, key: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  __sub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __truediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __xor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  display(self) -> 'None'
     |      shows graphical representation of expression
     |  
     |  total_derivative(self) -> 'Node'
     |      returns an expression tree representing the total derivative of this tree.
     |      the total derivative of f is defined as sum(f.derivative(var) for var in f.dependencies)
    
    class IsEqual(ComparisonOperator)
     |  IsEqual(*args: 'Node') -> 'None'
     |  
     |  Equality operator node
     |  
     |  Method resolution order:
     |      IsEqual
     |      ComparisonOperator
     |      ArbitraryOperator
     |      Node
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  symbol = '=='
     |  
     |  wolfram_func = 'EqualTo'
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ComparisonOperator:
     |  
     |  derivative(self, variable: 'str') -> 'Node'
     |      returns an expression tree representing the (partial) derivative to the passed variable of this tree
     |  
     |  evaluate(self, var_dict: 'Optional[Variables]' = None) -> 'bool'
     |      Evaluates the expression tree using the values from var_dict, returns int or float
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ArbitraryOperator:
     |  
     |  __init__(self, *args: 'Node') -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  dependencies(self) -> 'set[str]'
     |      returns set of all variables present in the tree
     |  
     |  infix(self) -> 'str'
     |      returns infix representation of the tree
     |  
     |  list_nodes(self) -> 'list[Node]'
     |      returns a list of all nodes in the tree
     |  
     |  mathml(self) -> 'str'
     |      returns the MathML representation of the tree
     |  
     |  simplify(self, var_dict: 'Optional[Variables]' = None) -> 'Node'
     |      returns a simplified version of the tree
     |  
     |  substitute(self, var: 'str', sub: 'Node') -> 'Node'
     |      substitute a variable with an expression inside this tree, returns the resulting tree
     |  
     |  wolfram(self) -> 'str'
     |      return wolfram language representation of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ArbitraryOperator:
     |  
     |  children
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Node:
     |  
     |  __add__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __and__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __bool__(self) -> 'bool'
     |  
     |  __complex__(self) -> 'complex'
     |  
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  __float__(self) -> 'float'
     |  
     |  __ge__(self, other: 'Any') -> 'bool'
     |      Return self>=value.
     |  
     |  __gt__(self, other: 'Any') -> 'bool'
     |      Return self>value.
     |  
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |  
     |  __int__(self) -> 'int'
     |  
     |  __invert__(self) -> 'Not'
     |  
     |  __le__(self, other: 'Any') -> 'bool'
     |      Return self<=value.
     |  
     |  __lt__(self, other: 'Any') -> 'bool'
     |      Return self<value.
     |  
     |  __mul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ne__(self, other: 'Any') -> 'bool'
     |      Return self!=value.
     |  
     |  __neg__(self) -> 'Negate'
     |  
     |  __or__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __pow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __radd__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __rand__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __rmul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ror__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __rpow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __rsub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rtruediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rxor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  __setattr__(self, key: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  __sub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __truediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __xor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  display(self) -> 'None'
     |      shows graphical representation of expression
     |  
     |  total_derivative(self) -> 'Node'
     |      returns an expression tree representing the total derivative of this tree.
     |      the total derivative of f is defined as sum(f.derivative(var) for var in f.dependencies)
    
    class LessEqual(ComparisonOperator)
     |  LessEqual(*args: 'Node') -> 'None'
     |  
     |  Less-equal operator node
     |  
     |  Method resolution order:
     |      LessEqual
     |      ComparisonOperator
     |      ArbitraryOperator
     |      Node
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  symbol = '<='
     |  
     |  wolfram_func = 'LessEqual'
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ComparisonOperator:
     |  
     |  derivative(self, variable: 'str') -> 'Node'
     |      returns an expression tree representing the (partial) derivative to the passed variable of this tree
     |  
     |  evaluate(self, var_dict: 'Optional[Variables]' = None) -> 'bool'
     |      Evaluates the expression tree using the values from var_dict, returns int or float
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ArbitraryOperator:
     |  
     |  __init__(self, *args: 'Node') -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  dependencies(self) -> 'set[str]'
     |      returns set of all variables present in the tree
     |  
     |  infix(self) -> 'str'
     |      returns infix representation of the tree
     |  
     |  list_nodes(self) -> 'list[Node]'
     |      returns a list of all nodes in the tree
     |  
     |  mathml(self) -> 'str'
     |      returns the MathML representation of the tree
     |  
     |  simplify(self, var_dict: 'Optional[Variables]' = None) -> 'Node'
     |      returns a simplified version of the tree
     |  
     |  substitute(self, var: 'str', sub: 'Node') -> 'Node'
     |      substitute a variable with an expression inside this tree, returns the resulting tree
     |  
     |  wolfram(self) -> 'str'
     |      return wolfram language representation of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ArbitraryOperator:
     |  
     |  children
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Node:
     |  
     |  __add__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __and__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __bool__(self) -> 'bool'
     |  
     |  __complex__(self) -> 'complex'
     |  
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  __float__(self) -> 'float'
     |  
     |  __ge__(self, other: 'Any') -> 'bool'
     |      Return self>=value.
     |  
     |  __gt__(self, other: 'Any') -> 'bool'
     |      Return self>value.
     |  
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |  
     |  __int__(self) -> 'int'
     |  
     |  __invert__(self) -> 'Not'
     |  
     |  __le__(self, other: 'Any') -> 'bool'
     |      Return self<=value.
     |  
     |  __lt__(self, other: 'Any') -> 'bool'
     |      Return self<value.
     |  
     |  __mul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ne__(self, other: 'Any') -> 'bool'
     |      Return self!=value.
     |  
     |  __neg__(self) -> 'Negate'
     |  
     |  __or__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __pow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __radd__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __rand__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __rmul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ror__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __rpow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __rsub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rtruediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rxor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  __setattr__(self, key: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  __sub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __truediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __xor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  display(self) -> 'None'
     |      shows graphical representation of expression
     |  
     |  total_derivative(self) -> 'Node'
     |      returns an expression tree representing the total derivative of this tree.
     |      the total derivative of f is defined as sum(f.derivative(var) for var in f.dependencies)
    
    class LessThan(ComparisonOperator)
     |  LessThan(*args: 'Node') -> 'None'
     |  
     |  Less-than operator node
     |  
     |  Method resolution order:
     |      LessThan
     |      ComparisonOperator
     |      ArbitraryOperator
     |      Node
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  symbol = '<'
     |  
     |  wolfram_func = 'Less'
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ComparisonOperator:
     |  
     |  derivative(self, variable: 'str') -> 'Node'
     |      returns an expression tree representing the (partial) derivative to the passed variable of this tree
     |  
     |  evaluate(self, var_dict: 'Optional[Variables]' = None) -> 'bool'
     |      Evaluates the expression tree using the values from var_dict, returns int or float
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ArbitraryOperator:
     |  
     |  __init__(self, *args: 'Node') -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  dependencies(self) -> 'set[str]'
     |      returns set of all variables present in the tree
     |  
     |  infix(self) -> 'str'
     |      returns infix representation of the tree
     |  
     |  list_nodes(self) -> 'list[Node]'
     |      returns a list of all nodes in the tree
     |  
     |  mathml(self) -> 'str'
     |      returns the MathML representation of the tree
     |  
     |  simplify(self, var_dict: 'Optional[Variables]' = None) -> 'Node'
     |      returns a simplified version of the tree
     |  
     |  substitute(self, var: 'str', sub: 'Node') -> 'Node'
     |      substitute a variable with an expression inside this tree, returns the resulting tree
     |  
     |  wolfram(self) -> 'str'
     |      return wolfram language representation of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ArbitraryOperator:
     |  
     |  children
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Node:
     |  
     |  __add__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __and__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __bool__(self) -> 'bool'
     |  
     |  __complex__(self) -> 'complex'
     |  
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  __float__(self) -> 'float'
     |  
     |  __ge__(self, other: 'Any') -> 'bool'
     |      Return self>=value.
     |  
     |  __gt__(self, other: 'Any') -> 'bool'
     |      Return self>value.
     |  
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |  
     |  __int__(self) -> 'int'
     |  
     |  __invert__(self) -> 'Not'
     |  
     |  __le__(self, other: 'Any') -> 'bool'
     |      Return self<=value.
     |  
     |  __lt__(self, other: 'Any') -> 'bool'
     |      Return self<value.
     |  
     |  __mul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ne__(self, other: 'Any') -> 'bool'
     |      Return self!=value.
     |  
     |  __neg__(self) -> 'Negate'
     |  
     |  __or__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __pow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __radd__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __rand__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __rmul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ror__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __rpow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __rsub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rtruediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rxor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  __setattr__(self, key: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  __sub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __truediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __xor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  display(self) -> 'None'
     |      shows graphical representation of expression
     |  
     |  total_derivative(self) -> 'Node'
     |      returns an expression tree representing the total derivative of this tree.
     |      the total derivative of f is defined as sum(f.derivative(var) for var in f.dependencies)
    
    class Logarithm(BinaryOperator)
     |  Logarithm(child1: 'Node', child2: 'Optional[Node]' = None)
     |  
     |  Logarithm operator node, child 2 is base. default base is e
     |  
     |  Method resolution order:
     |      Logarithm
     |      BinaryOperator
     |      Node
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, child1: 'Node', child2: 'Optional[Node]' = None)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  derivative(self, variable: 'str') -> 'Node'
     |      returns an expression tree representing the (partial) derivative to the passed variable of this tree
     |  
     |  evaluate(self, var_dict: 'Optional[Variables]' = None) -> 'ConstantType'
     |      Evaluates the expression tree using the values from var_dict, returns int or float
     |  
     |  infix(self) -> 'str'
     |      returns infix representation of the tree
     |  
     |  mathml(self) -> 'str'
     |      returns the MathML representation of the tree
     |  
     |  simplify(self, var_dict: 'Optional[Variables]' = None) -> 'Node'
     |      returns a simplified version of the tree
     |  
     |  wolfram(self) -> 'str'
     |      return wolfram language representation of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  symbol = 'log'
     |  
     |  wolfram_func = 'Log'
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from BinaryOperator:
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  list_nodes(self) -> 'list[Node]'
     |      return a list of all nodes in the tree
     |  
     |  substitute(self, var: 'str', sub: 'Node') -> 'Node'
     |      substitute a variable with an expression inside this tree, returns the resulting tree
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from BinaryOperator:
     |  
     |  child1
     |  
     |  child2
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Node:
     |  
     |  __add__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __and__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __bool__(self) -> 'bool'
     |  
     |  __complex__(self) -> 'complex'
     |  
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  __float__(self) -> 'float'
     |  
     |  __ge__(self, other: 'Any') -> 'bool'
     |      Return self>=value.
     |  
     |  __gt__(self, other: 'Any') -> 'bool'
     |      Return self>value.
     |  
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |  
     |  __int__(self) -> 'int'
     |  
     |  __invert__(self) -> 'Not'
     |  
     |  __le__(self, other: 'Any') -> 'bool'
     |      Return self<=value.
     |  
     |  __lt__(self, other: 'Any') -> 'bool'
     |      Return self<value.
     |  
     |  __mul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ne__(self, other: 'Any') -> 'bool'
     |      Return self!=value.
     |  
     |  __neg__(self) -> 'Negate'
     |  
     |  __or__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __pow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __radd__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __rand__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __rmul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ror__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __rpow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __rsub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rtruediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rxor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  __setattr__(self, key: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  __sub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __truediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __xor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  dependencies(self) -> 'set[str]'
     |      returns set of all variables present in the tree
     |  
     |  display(self) -> 'None'
     |      shows graphical representation of expression
     |  
     |  total_derivative(self) -> 'Node'
     |      returns an expression tree representing the total derivative of this tree.
     |      the total derivative of f is defined as sum(f.derivative(var) for var in f.dependencies)
    
    class Modulus(ArbitraryOperator)
     |  Modulus(*args: 'Node') -> 'None'
     |  
     |  Modulo operator node
     |  
     |  Method resolution order:
     |      Modulus
     |      ArbitraryOperator
     |      Node
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  derivative(self, variable: 'str') -> 'Node'
     |      returns an expression tree representing the (partial) derivative to the passed variable of this tree
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  symbol = '%'
     |  
     |  wolfram_func = 'Mod'
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ArbitraryOperator:
     |  
     |  __init__(self, *args: 'Node') -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  dependencies(self) -> 'set[str]'
     |      returns set of all variables present in the tree
     |  
     |  evaluate(self, var_dict: 'Optional[Variables]' = None) -> 'ConstantType'
     |      Evaluates the expression tree using the values from var_dict, returns int or float
     |  
     |  infix(self) -> 'str'
     |      returns infix representation of the tree
     |  
     |  list_nodes(self) -> 'list[Node]'
     |      returns a list of all nodes in the tree
     |  
     |  mathml(self) -> 'str'
     |      returns the MathML representation of the tree
     |  
     |  simplify(self, var_dict: 'Optional[Variables]' = None) -> 'Node'
     |      returns a simplified version of the tree
     |  
     |  substitute(self, var: 'str', sub: 'Node') -> 'Node'
     |      substitute a variable with an expression inside this tree, returns the resulting tree
     |  
     |  wolfram(self) -> 'str'
     |      return wolfram language representation of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ArbitraryOperator:
     |  
     |  children
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Node:
     |  
     |  __add__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __and__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __bool__(self) -> 'bool'
     |  
     |  __complex__(self) -> 'complex'
     |  
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  __float__(self) -> 'float'
     |  
     |  __ge__(self, other: 'Any') -> 'bool'
     |      Return self>=value.
     |  
     |  __gt__(self, other: 'Any') -> 'bool'
     |      Return self>value.
     |  
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |  
     |  __int__(self) -> 'int'
     |  
     |  __invert__(self) -> 'Not'
     |  
     |  __le__(self, other: 'Any') -> 'bool'
     |      Return self<=value.
     |  
     |  __lt__(self, other: 'Any') -> 'bool'
     |      Return self<value.
     |  
     |  __mul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ne__(self, other: 'Any') -> 'bool'
     |      Return self!=value.
     |  
     |  __neg__(self) -> 'Negate'
     |  
     |  __or__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __pow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __radd__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __rand__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __rmul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ror__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __rpow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __rsub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rtruediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rxor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  __setattr__(self, key: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  __sub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __truediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __xor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  display(self) -> 'None'
     |      shows graphical representation of expression
     |  
     |  total_derivative(self) -> 'Node'
     |      returns an expression tree representing the total derivative of this tree.
     |      the total derivative of f is defined as sum(f.derivative(var) for var in f.dependencies)
    
    class Negate(UnaryOperator)
     |  Negate(child: 'Node') -> 'None'
     |  
     |  Unary negative operator
     |  
     |  Method resolution order:
     |      Negate
     |      UnaryOperator
     |      Node
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  derivative(self, variable: 'str') -> 'Node'
     |      returns an expression tree representing the (partial) derivative to the passed variable of this tree
     |  
     |  evaluate(self, var_dict: 'Optional[Variables]' = None) -> 'ConstantType'
     |      Evaluates the expression tree using the values from var_dict, returns int or float
     |  
     |  infix(self) -> 'str'
     |      returns infix representation of the tree
     |  
     |  mathml(self) -> 'str'
     |      returns the MathML representation of the tree
     |  
     |  simplify(self, var_dict: 'Optional[Variables]' = None) -> 'Node'
     |      returns a simplified version of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  symbol = '-'
     |  
     |  wolfram_func = 'Minus'
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from UnaryOperator:
     |  
     |  __init__(self, child: 'Node') -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  dependencies(self) -> 'set[str]'
     |      returns set of all variables present in the tree
     |  
     |  list_nodes(self) -> 'list[Node]'
     |      returns a list of all nodes in the tree
     |  
     |  substitute(self, var: 'str', sub: 'Node') -> 'Node'
     |      substitute a variable with an expression inside this tree, returns the resulting tree
     |  
     |  wolfram(self) -> 'str'
     |      return wolfram language representation of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from UnaryOperator:
     |  
     |  child
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Node:
     |  
     |  __add__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __and__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __bool__(self) -> 'bool'
     |  
     |  __complex__(self) -> 'complex'
     |  
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  __float__(self) -> 'float'
     |  
     |  __ge__(self, other: 'Any') -> 'bool'
     |      Return self>=value.
     |  
     |  __gt__(self, other: 'Any') -> 'bool'
     |      Return self>value.
     |  
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |  
     |  __int__(self) -> 'int'
     |  
     |  __invert__(self) -> 'Not'
     |  
     |  __le__(self, other: 'Any') -> 'bool'
     |      Return self<=value.
     |  
     |  __lt__(self, other: 'Any') -> 'bool'
     |      Return self<value.
     |  
     |  __mul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ne__(self, other: 'Any') -> 'bool'
     |      Return self!=value.
     |  
     |  __neg__(self) -> 'Negate'
     |  
     |  __or__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __pow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __radd__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __rand__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __rmul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ror__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __rpow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __rsub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rtruediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rxor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  __setattr__(self, key: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  __sub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __truediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __xor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  display(self) -> 'None'
     |      shows graphical representation of expression
     |  
     |  total_derivative(self) -> 'Node'
     |      returns an expression tree representing the total derivative of this tree.
     |      the total derivative of f is defined as sum(f.derivative(var) for var in f.dependencies)
    
    class Node(builtins.object)
     |  Node() -> 'None'
     |  
     |  Abstract Base Class for any node in the expression tree
     |  
     |  Methods defined here:
     |  
     |  __add__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __and__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __bool__(self) -> 'bool'
     |  
     |  __complex__(self) -> 'complex'
     |  
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  __float__(self) -> 'float'
     |  
     |  __ge__(self, other: 'Any') -> 'bool'
     |      Return self>=value.
     |  
     |  __gt__(self, other: 'Any') -> 'bool'
     |      Return self>value.
     |  
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |  
     |  __init__(self) -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __int__(self) -> 'int'
     |  
     |  __invert__(self) -> 'Not'
     |  
     |  __le__(self, other: 'Any') -> 'bool'
     |      Return self<=value.
     |  
     |  __lt__(self, other: 'Any') -> 'bool'
     |      Return self<value.
     |  
     |  __mul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ne__(self, other: 'Any') -> 'bool'
     |      Return self!=value.
     |  
     |  __neg__(self) -> 'Negate'
     |  
     |  __or__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __pow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __radd__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __rand__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  __rmul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ror__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __rpow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __rsub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rtruediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rxor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  __setattr__(self, key: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  __sub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __truediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __xor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  dependencies(self) -> 'set[str]'
     |      returns set of all variables present in the tree
     |  
     |  derivative(self, variable: 'str') -> 'Node'
     |      returns an expression tree representing the (partial) derivative to the passed variable of this tree
     |  
     |  display(self) -> 'None'
     |      shows graphical representation of expression
     |  
     |  evaluate(self, var_dict: 'Optional[Variables]' = None) -> 'ConstantType'
     |      Evaluates the expression tree using the values from var_dict, returns int or float
     |  
     |  infix(self) -> 'str'
     |      returns infix representation of the tree
     |  
     |  list_nodes(self) -> 'list[Node]'
     |      return a list of all nodes in the tree
     |  
     |  mathml(self) -> 'str'
     |      returns the MathML representation of the tree
     |  
     |  simplify(self, var_dict: 'Optional[Variables]' = None) -> 'Node'
     |      returns a simplified version of the tree
     |  
     |  substitute(self, var: 'str', sub: 'Node') -> 'Node'
     |      substitute a variable with an expression inside this tree, returns the resulting tree
     |  
     |  total_derivative(self) -> 'Node'
     |      returns an expression tree representing the total derivative of this tree.
     |      the total derivative of f is defined as sum(f.derivative(var) for var in f.dependencies)
     |  
     |  wolfram(self) -> 'str'
     |      return wolfram language representation of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset({'__repr__', 'derivative', 'evaluate',...
    
    class Not(UnaryOperator)
     |  Not(child: 'Node') -> 'None'
     |  
     |  Logical not operator
     |  
     |  Method resolution order:
     |      Not
     |      UnaryOperator
     |      Node
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  derivative(self, variable: 'str') -> 'Node'
     |      returns an expression tree representing the (partial) derivative to the passed variable of this tree
     |  
     |  evaluate(self, var_dict: 'Optional[Variables]' = None) -> 'bool'
     |      Evaluates the expression tree using the values from var_dict, returns int or float
     |  
     |  infix(self) -> 'str'
     |      returns infix representation of the tree
     |  
     |  mathml(self) -> 'str'
     |      returns the MathML representation of the tree
     |  
     |  simplify(self, var_dict: 'Optional[Variables]' = None) -> 'Node'
     |      returns a simplified version of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  symbol = '~'
     |  
     |  wolfram_func = 'Not'
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from UnaryOperator:
     |  
     |  __init__(self, child: 'Node') -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  dependencies(self) -> 'set[str]'
     |      returns set of all variables present in the tree
     |  
     |  list_nodes(self) -> 'list[Node]'
     |      returns a list of all nodes in the tree
     |  
     |  substitute(self, var: 'str', sub: 'Node') -> 'Node'
     |      substitute a variable with an expression inside this tree, returns the resulting tree
     |  
     |  wolfram(self) -> 'str'
     |      return wolfram language representation of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from UnaryOperator:
     |  
     |  child
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Node:
     |  
     |  __add__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __and__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __bool__(self) -> 'bool'
     |  
     |  __complex__(self) -> 'complex'
     |  
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  __float__(self) -> 'float'
     |  
     |  __ge__(self, other: 'Any') -> 'bool'
     |      Return self>=value.
     |  
     |  __gt__(self, other: 'Any') -> 'bool'
     |      Return self>value.
     |  
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |  
     |  __int__(self) -> 'int'
     |  
     |  __invert__(self) -> 'Not'
     |  
     |  __le__(self, other: 'Any') -> 'bool'
     |      Return self<=value.
     |  
     |  __lt__(self, other: 'Any') -> 'bool'
     |      Return self<value.
     |  
     |  __mul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ne__(self, other: 'Any') -> 'bool'
     |      Return self!=value.
     |  
     |  __neg__(self) -> 'Negate'
     |  
     |  __or__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __pow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __radd__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __rand__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __rmul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ror__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __rpow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __rsub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rtruediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rxor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  __setattr__(self, key: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  __sub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __truediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __xor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  display(self) -> 'None'
     |      shows graphical representation of expression
     |  
     |  total_derivative(self) -> 'Node'
     |      returns an expression tree representing the total derivative of this tree.
     |      the total derivative of f is defined as sum(f.derivative(var) for var in f.dependencies)
    
    class Or(ArbitraryLogicalOperator)
     |  Or(*args: 'Node') -> 'None'
     |  
     |  logical OR operator node
     |  
     |  Method resolution order:
     |      Or
     |      ArbitraryLogicalOperator
     |      ArbitraryOperator
     |      Node
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  symbol = '|'
     |  
     |  wolfram_func = 'Or'
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ArbitraryLogicalOperator:
     |  
     |  derivative(self, variable: 'str') -> 'Node'
     |      returns an expression tree representing the (partial) derivative to the passed variable of this tree
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ArbitraryOperator:
     |  
     |  __init__(self, *args: 'Node') -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  dependencies(self) -> 'set[str]'
     |      returns set of all variables present in the tree
     |  
     |  evaluate(self, var_dict: 'Optional[Variables]' = None) -> 'ConstantType'
     |      Evaluates the expression tree using the values from var_dict, returns int or float
     |  
     |  infix(self) -> 'str'
     |      returns infix representation of the tree
     |  
     |  list_nodes(self) -> 'list[Node]'
     |      returns a list of all nodes in the tree
     |  
     |  mathml(self) -> 'str'
     |      returns the MathML representation of the tree
     |  
     |  simplify(self, var_dict: 'Optional[Variables]' = None) -> 'Node'
     |      returns a simplified version of the tree
     |  
     |  substitute(self, var: 'str', sub: 'Node') -> 'Node'
     |      substitute a variable with an expression inside this tree, returns the resulting tree
     |  
     |  wolfram(self) -> 'str'
     |      return wolfram language representation of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ArbitraryOperator:
     |  
     |  children
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Node:
     |  
     |  __add__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __and__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __bool__(self) -> 'bool'
     |  
     |  __complex__(self) -> 'complex'
     |  
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  __float__(self) -> 'float'
     |  
     |  __ge__(self, other: 'Any') -> 'bool'
     |      Return self>=value.
     |  
     |  __gt__(self, other: 'Any') -> 'bool'
     |      Return self>value.
     |  
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |  
     |  __int__(self) -> 'int'
     |  
     |  __invert__(self) -> 'Not'
     |  
     |  __le__(self, other: 'Any') -> 'bool'
     |      Return self<=value.
     |  
     |  __lt__(self, other: 'Any') -> 'bool'
     |      Return self<value.
     |  
     |  __mul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ne__(self, other: 'Any') -> 'bool'
     |      Return self!=value.
     |  
     |  __neg__(self) -> 'Negate'
     |  
     |  __or__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __pow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __radd__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __rand__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __rmul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ror__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __rpow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __rsub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rtruediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rxor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  __setattr__(self, key: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  __sub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __truediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __xor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  display(self) -> 'None'
     |      shows graphical representation of expression
     |  
     |  total_derivative(self) -> 'Node'
     |      returns an expression tree representing the total derivative of this tree.
     |      the total derivative of f is defined as sum(f.derivative(var) for var in f.dependencies)
    
    class Pi(Constant)
     |  Pi() -> 'None'
     |  
     |  mathematical constant in expression tree
     |  
     |  Method resolution order:
     |      Pi
     |      Constant
     |      Term
     |      Node
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self) -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  evaluate(self, var_dict: 'Optional[Variables]' = None) -> 'ConstantType'
     |      Evaluates the expression tree using the values from var_dict, returns int or float
     |  
     |  infix(self) -> 'str'
     |      returns infix representation of the tree
     |  
     |  mathml(self) -> 'str'
     |      returns the MathML representation of the tree
     |  
     |  simplify(self, var_dict: 'Optional[Variables]' = None) -> 'Node'
     |      returns a simplified version of the tree
     |  
     |  wolfram(self) -> 'str'
     |      return wolfram language representation of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  value
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Constant:
     |  
     |  derivative(self, variable: 'str') -> 'Node'
     |      returns an expression tree representing the (partial) derivative to the passed variable of this tree
     |  
     |  substitute(self, var: 'str', sub: 'Node') -> 'Node'
     |      substitute a variable with an expression inside this tree, returns the resulting tree
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Term:
     |  
     |  list_nodes(self) -> 'list[Node]'
     |      returns a list of all nodes in the tree
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Node:
     |  
     |  __add__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __and__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __bool__(self) -> 'bool'
     |  
     |  __complex__(self) -> 'complex'
     |  
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  __float__(self) -> 'float'
     |  
     |  __ge__(self, other: 'Any') -> 'bool'
     |      Return self>=value.
     |  
     |  __gt__(self, other: 'Any') -> 'bool'
     |      Return self>value.
     |  
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |  
     |  __int__(self) -> 'int'
     |  
     |  __invert__(self) -> 'Not'
     |  
     |  __le__(self, other: 'Any') -> 'bool'
     |      Return self<=value.
     |  
     |  __lt__(self, other: 'Any') -> 'bool'
     |      Return self<value.
     |  
     |  __mul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ne__(self, other: 'Any') -> 'bool'
     |      Return self!=value.
     |  
     |  __neg__(self) -> 'Negate'
     |  
     |  __or__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __pow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __radd__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __rand__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __rmul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ror__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __rpow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __rsub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rtruediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rxor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  __setattr__(self, key: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  __sub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __truediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __xor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  dependencies(self) -> 'set[str]'
     |      returns set of all variables present in the tree
     |  
     |  display(self) -> 'None'
     |      shows graphical representation of expression
     |  
     |  total_derivative(self) -> 'Node'
     |      returns an expression tree representing the total derivative of this tree.
     |      the total derivative of f is defined as sum(f.derivative(var) for var in f.dependencies)
    
    class Piecewise(Node)
     |  Piecewise(expressions: 'tuple[tuple[Node, Node], ...]', default: 'Optional[Node]' = None) -> 'None'
     |  
     |  Piecewise function node
     |  
     |  Method resolution order:
     |      Piecewise
     |      Node
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, expressions: 'tuple[tuple[Node, Node], ...]', default: 'Optional[Node]' = None) -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  derivative(self, variable: 'str') -> 'Node'
     |      returns an expression tree representing the (partial) derivative to the passed variable of this tree
     |  
     |  evaluate(self, var_dict: 'Optional[Variables]' = None) -> 'ConstantType'
     |      Evaluates the expression tree using the values from var_dict, returns int or float
     |  
     |  infix(self) -> 'str'
     |      returns infix representation of the tree
     |  
     |  list_nodes(self) -> 'list[Node]'
     |      returns a list of all nodes in the tree
     |  
     |  mathml(self) -> 'str'
     |      returns the MathML representation of the tree
     |  
     |  simplify(self, var_dict: 'Optional[Variables]' = None) -> 'Node'
     |      returns a simplified version of the tree
     |  
     |  substitute(self, var: 'str', sub: 'Node') -> 'Node'
     |      substitute a variable with an expression inside this tree, returns the resulting tree
     |  
     |  wolfram(self) -> 'str'
     |      return wolfram language representation of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  default
     |  
     |  expressions
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  symbol = 'piecewise'
     |  
     |  wolfram_func = 'Piecewise'
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Node:
     |  
     |  __add__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __and__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __bool__(self) -> 'bool'
     |  
     |  __complex__(self) -> 'complex'
     |  
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  __float__(self) -> 'float'
     |  
     |  __ge__(self, other: 'Any') -> 'bool'
     |      Return self>=value.
     |  
     |  __gt__(self, other: 'Any') -> 'bool'
     |      Return self>value.
     |  
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |  
     |  __int__(self) -> 'int'
     |  
     |  __invert__(self) -> 'Not'
     |  
     |  __le__(self, other: 'Any') -> 'bool'
     |      Return self<=value.
     |  
     |  __lt__(self, other: 'Any') -> 'bool'
     |      Return self<value.
     |  
     |  __mul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ne__(self, other: 'Any') -> 'bool'
     |      Return self!=value.
     |  
     |  __neg__(self) -> 'Negate'
     |  
     |  __or__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __pow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __radd__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __rand__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __rmul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ror__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __rpow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __rsub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rtruediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rxor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  __setattr__(self, key: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  __sub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __truediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __xor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  dependencies(self) -> 'set[str]'
     |      returns set of all variables present in the tree
     |  
     |  display(self) -> 'None'
     |      shows graphical representation of expression
     |  
     |  total_derivative(self) -> 'Node'
     |      returns an expression tree representing the total derivative of this tree.
     |      the total derivative of f is defined as sum(f.derivative(var) for var in f.dependencies)
    
    class Product(ArbitraryOperator)
     |  Product(*args: 'Node') -> 'None'
     |  
     |  Multiplication operator node
     |  
     |  Method resolution order:
     |      Product
     |      ArbitraryOperator
     |      Node
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  derivative(self, variable: 'str') -> 'Node'
     |      returns an expression tree representing the (partial) derivative to the passed variable of this tree
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  symbol = '*'
     |  
     |  wolfram_func = 'Times'
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ArbitraryOperator:
     |  
     |  __init__(self, *args: 'Node') -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  dependencies(self) -> 'set[str]'
     |      returns set of all variables present in the tree
     |  
     |  evaluate(self, var_dict: 'Optional[Variables]' = None) -> 'ConstantType'
     |      Evaluates the expression tree using the values from var_dict, returns int or float
     |  
     |  infix(self) -> 'str'
     |      returns infix representation of the tree
     |  
     |  list_nodes(self) -> 'list[Node]'
     |      returns a list of all nodes in the tree
     |  
     |  mathml(self) -> 'str'
     |      returns the MathML representation of the tree
     |  
     |  simplify(self, var_dict: 'Optional[Variables]' = None) -> 'Node'
     |      returns a simplified version of the tree
     |  
     |  substitute(self, var: 'str', sub: 'Node') -> 'Node'
     |      substitute a variable with an expression inside this tree, returns the resulting tree
     |  
     |  wolfram(self) -> 'str'
     |      return wolfram language representation of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ArbitraryOperator:
     |  
     |  children
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Node:
     |  
     |  __add__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __and__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __bool__(self) -> 'bool'
     |  
     |  __complex__(self) -> 'complex'
     |  
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  __float__(self) -> 'float'
     |  
     |  __ge__(self, other: 'Any') -> 'bool'
     |      Return self>=value.
     |  
     |  __gt__(self, other: 'Any') -> 'bool'
     |      Return self>value.
     |  
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |  
     |  __int__(self) -> 'int'
     |  
     |  __invert__(self) -> 'Not'
     |  
     |  __le__(self, other: 'Any') -> 'bool'
     |      Return self<=value.
     |  
     |  __lt__(self, other: 'Any') -> 'bool'
     |      Return self<value.
     |  
     |  __mul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ne__(self, other: 'Any') -> 'bool'
     |      Return self!=value.
     |  
     |  __neg__(self) -> 'Negate'
     |  
     |  __or__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __pow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __radd__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __rand__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __rmul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ror__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __rpow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __rsub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rtruediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rxor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  __setattr__(self, key: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  __sub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __truediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __xor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  display(self) -> 'None'
     |      shows graphical representation of expression
     |  
     |  total_derivative(self) -> 'Node'
     |      returns an expression tree representing the total derivative of this tree.
     |      the total derivative of f is defined as sum(f.derivative(var) for var in f.dependencies)
    
    class Rational(Constant)
     |  Rational(value: 'Fraction') -> 'None'
     |  
     |  rational number in expression tree
     |  
     |  Method resolution order:
     |      Rational
     |      Constant
     |      Term
     |      Node
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, value: 'Fraction') -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  evaluate(self, var_dict: 'Optional[Variables]' = None) -> 'Fraction'
     |      Evaluates the expression tree using the values from var_dict, returns int or float
     |  
     |  infix(self) -> 'str'
     |      returns infix representation of the tree
     |  
     |  mathml(self) -> 'str'
     |      returns the MathML representation of the tree
     |  
     |  wolfram(self) -> 'str'
     |      return wolfram language representation of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  value
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Constant:
     |  
     |  derivative(self, variable: 'str') -> 'Node'
     |      returns an expression tree representing the (partial) derivative to the passed variable of this tree
     |  
     |  simplify(self, var_dict: 'Optional[Variables]' = None) -> 'Node'
     |      returns a simplified version of the tree
     |  
     |  substitute(self, var: 'str', sub: 'Node') -> 'Node'
     |      substitute a variable with an expression inside this tree, returns the resulting tree
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Term:
     |  
     |  list_nodes(self) -> 'list[Node]'
     |      returns a list of all nodes in the tree
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Node:
     |  
     |  __add__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __and__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __bool__(self) -> 'bool'
     |  
     |  __complex__(self) -> 'complex'
     |  
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  __float__(self) -> 'float'
     |  
     |  __ge__(self, other: 'Any') -> 'bool'
     |      Return self>=value.
     |  
     |  __gt__(self, other: 'Any') -> 'bool'
     |      Return self>value.
     |  
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |  
     |  __int__(self) -> 'int'
     |  
     |  __invert__(self) -> 'Not'
     |  
     |  __le__(self, other: 'Any') -> 'bool'
     |      Return self<=value.
     |  
     |  __lt__(self, other: 'Any') -> 'bool'
     |      Return self<value.
     |  
     |  __mul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ne__(self, other: 'Any') -> 'bool'
     |      Return self!=value.
     |  
     |  __neg__(self) -> 'Negate'
     |  
     |  __or__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __pow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __radd__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __rand__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __rmul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ror__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __rpow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __rsub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rtruediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rxor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  __setattr__(self, key: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  __sub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __truediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __xor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  dependencies(self) -> 'set[str]'
     |      returns set of all variables present in the tree
     |  
     |  display(self) -> 'None'
     |      shows graphical representation of expression
     |  
     |  total_derivative(self) -> 'Node'
     |      returns an expression tree representing the total derivative of this tree.
     |      the total derivative of f is defined as sum(f.derivative(var) for var in f.dependencies)
    
    class Real(Constant)
     |  Real(value: 'float') -> 'None'
     |  
     |  real number in expression tree
     |  
     |  Method resolution order:
     |      Real
     |      Constant
     |      Term
     |      Node
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, value: 'float') -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  evaluate(self, var_dict: 'Optional[Variables]' = None) -> 'float'
     |      Evaluates the expression tree using the values from var_dict, returns int or float
     |  
     |  infix(self) -> 'str'
     |      returns infix representation of the tree
     |  
     |  mathml(self) -> 'str'
     |      returns the MathML representation of the tree
     |  
     |  wolfram(self) -> 'str'
     |      return wolfram language representation of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  value
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Constant:
     |  
     |  derivative(self, variable: 'str') -> 'Node'
     |      returns an expression tree representing the (partial) derivative to the passed variable of this tree
     |  
     |  simplify(self, var_dict: 'Optional[Variables]' = None) -> 'Node'
     |      returns a simplified version of the tree
     |  
     |  substitute(self, var: 'str', sub: 'Node') -> 'Node'
     |      substitute a variable with an expression inside this tree, returns the resulting tree
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Term:
     |  
     |  list_nodes(self) -> 'list[Node]'
     |      returns a list of all nodes in the tree
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Node:
     |  
     |  __add__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __and__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __bool__(self) -> 'bool'
     |  
     |  __complex__(self) -> 'complex'
     |  
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  __float__(self) -> 'float'
     |  
     |  __ge__(self, other: 'Any') -> 'bool'
     |      Return self>=value.
     |  
     |  __gt__(self, other: 'Any') -> 'bool'
     |      Return self>value.
     |  
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |  
     |  __int__(self) -> 'int'
     |  
     |  __invert__(self) -> 'Not'
     |  
     |  __le__(self, other: 'Any') -> 'bool'
     |      Return self<=value.
     |  
     |  __lt__(self, other: 'Any') -> 'bool'
     |      Return self<value.
     |  
     |  __mul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ne__(self, other: 'Any') -> 'bool'
     |      Return self!=value.
     |  
     |  __neg__(self) -> 'Negate'
     |  
     |  __or__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __pow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __radd__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __rand__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __rmul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ror__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __rpow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __rsub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rtruediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rxor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  __setattr__(self, key: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  __sub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __truediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __xor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  dependencies(self) -> 'set[str]'
     |      returns set of all variables present in the tree
     |  
     |  display(self) -> 'None'
     |      shows graphical representation of expression
     |  
     |  total_derivative(self) -> 'Node'
     |      returns an expression tree representing the total derivative of this tree.
     |      the total derivative of f is defined as sum(f.derivative(var) for var in f.dependencies)
    
    class Sine(UnaryOperator)
     |  Sine(child: 'Node') -> 'None'
     |  
     |  Sine operator node in radians
     |  
     |  Method resolution order:
     |      Sine
     |      UnaryOperator
     |      Node
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  derivative(self, variable: 'str') -> 'Node'
     |      returns an expression tree representing the (partial) derivative to the passed variable of this tree
     |  
     |  evaluate(self, var_dict: 'Optional[Variables]' = None) -> 'ConstantType'
     |      Evaluates the expression tree using the values from var_dict, returns int or float
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  symbol = 'sin'
     |  
     |  wolfram_func = 'Sin'
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from UnaryOperator:
     |  
     |  __init__(self, child: 'Node') -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  dependencies(self) -> 'set[str]'
     |      returns set of all variables present in the tree
     |  
     |  infix(self) -> 'str'
     |      returns infix representation of the tree
     |  
     |  list_nodes(self) -> 'list[Node]'
     |      returns a list of all nodes in the tree
     |  
     |  mathml(self) -> 'str'
     |      returns the MathML representation of the tree
     |  
     |  simplify(self, var_dict: 'Optional[Variables]' = None) -> 'Node'
     |      returns a simplified version of the tree
     |  
     |  substitute(self, var: 'str', sub: 'Node') -> 'Node'
     |      substitute a variable with an expression inside this tree, returns the resulting tree
     |  
     |  wolfram(self) -> 'str'
     |      return wolfram language representation of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from UnaryOperator:
     |  
     |  child
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Node:
     |  
     |  __add__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __and__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __bool__(self) -> 'bool'
     |  
     |  __complex__(self) -> 'complex'
     |  
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  __float__(self) -> 'float'
     |  
     |  __ge__(self, other: 'Any') -> 'bool'
     |      Return self>=value.
     |  
     |  __gt__(self, other: 'Any') -> 'bool'
     |      Return self>value.
     |  
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |  
     |  __int__(self) -> 'int'
     |  
     |  __invert__(self) -> 'Not'
     |  
     |  __le__(self, other: 'Any') -> 'bool'
     |      Return self<=value.
     |  
     |  __lt__(self, other: 'Any') -> 'bool'
     |      Return self<value.
     |  
     |  __mul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ne__(self, other: 'Any') -> 'bool'
     |      Return self!=value.
     |  
     |  __neg__(self) -> 'Negate'
     |  
     |  __or__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __pow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __radd__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __rand__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __rmul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ror__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __rpow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __rsub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rtruediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rxor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  __setattr__(self, key: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  __sub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __truediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __xor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  display(self) -> 'None'
     |      shows graphical representation of expression
     |  
     |  total_derivative(self) -> 'Node'
     |      returns an expression tree representing the total derivative of this tree.
     |      the total derivative of f is defined as sum(f.derivative(var) for var in f.dependencies)
    
    class Sum(ArbitraryOperator)
     |  Sum(*args: 'Node') -> 'None'
     |  
     |  Addition operator node
     |  
     |  Method resolution order:
     |      Sum
     |      ArbitraryOperator
     |      Node
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  derivative(self, variable: 'str') -> 'Node'
     |      returns an expression tree representing the (partial) derivative to the passed variable of this tree
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  symbol = '+'
     |  
     |  wolfram_func = 'Plus'
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ArbitraryOperator:
     |  
     |  __init__(self, *args: 'Node') -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  dependencies(self) -> 'set[str]'
     |      returns set of all variables present in the tree
     |  
     |  evaluate(self, var_dict: 'Optional[Variables]' = None) -> 'ConstantType'
     |      Evaluates the expression tree using the values from var_dict, returns int or float
     |  
     |  infix(self) -> 'str'
     |      returns infix representation of the tree
     |  
     |  list_nodes(self) -> 'list[Node]'
     |      returns a list of all nodes in the tree
     |  
     |  mathml(self) -> 'str'
     |      returns the MathML representation of the tree
     |  
     |  simplify(self, var_dict: 'Optional[Variables]' = None) -> 'Node'
     |      returns a simplified version of the tree
     |  
     |  substitute(self, var: 'str', sub: 'Node') -> 'Node'
     |      substitute a variable with an expression inside this tree, returns the resulting tree
     |  
     |  wolfram(self) -> 'str'
     |      return wolfram language representation of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ArbitraryOperator:
     |  
     |  children
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Node:
     |  
     |  __add__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __and__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __bool__(self) -> 'bool'
     |  
     |  __complex__(self) -> 'complex'
     |  
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  __float__(self) -> 'float'
     |  
     |  __ge__(self, other: 'Any') -> 'bool'
     |      Return self>=value.
     |  
     |  __gt__(self, other: 'Any') -> 'bool'
     |      Return self>value.
     |  
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |  
     |  __int__(self) -> 'int'
     |  
     |  __invert__(self) -> 'Not'
     |  
     |  __le__(self, other: 'Any') -> 'bool'
     |      Return self<=value.
     |  
     |  __lt__(self, other: 'Any') -> 'bool'
     |      Return self<value.
     |  
     |  __mul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ne__(self, other: 'Any') -> 'bool'
     |      Return self!=value.
     |  
     |  __neg__(self) -> 'Negate'
     |  
     |  __or__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __pow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __radd__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __rand__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __rmul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ror__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __rpow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __rsub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rtruediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rxor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  __setattr__(self, key: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  __sub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __truediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __xor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  display(self) -> 'None'
     |      shows graphical representation of expression
     |  
     |  total_derivative(self) -> 'Node'
     |      returns an expression tree representing the total derivative of this tree.
     |      the total derivative of f is defined as sum(f.derivative(var) for var in f.dependencies)
    
    class Tangent(UnaryOperator)
     |  Tangent(child: 'Node') -> 'None'
     |  
     |  Tangent operator node in radians
     |  
     |  Method resolution order:
     |      Tangent
     |      UnaryOperator
     |      Node
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  derivative(self, variable: 'str') -> 'Node'
     |      returns an expression tree representing the (partial) derivative to the passed variable of this tree
     |  
     |  evaluate(self, var_dict: 'Optional[Variables]' = None) -> 'ConstantType'
     |      Evaluates the expression tree using the values from var_dict, returns int or float
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  symbol = 'tan'
     |  
     |  wolfram_func = 'Tan'
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from UnaryOperator:
     |  
     |  __init__(self, child: 'Node') -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  dependencies(self) -> 'set[str]'
     |      returns set of all variables present in the tree
     |  
     |  infix(self) -> 'str'
     |      returns infix representation of the tree
     |  
     |  list_nodes(self) -> 'list[Node]'
     |      returns a list of all nodes in the tree
     |  
     |  mathml(self) -> 'str'
     |      returns the MathML representation of the tree
     |  
     |  simplify(self, var_dict: 'Optional[Variables]' = None) -> 'Node'
     |      returns a simplified version of the tree
     |  
     |  substitute(self, var: 'str', sub: 'Node') -> 'Node'
     |      substitute a variable with an expression inside this tree, returns the resulting tree
     |  
     |  wolfram(self) -> 'str'
     |      return wolfram language representation of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from UnaryOperator:
     |  
     |  child
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Node:
     |  
     |  __add__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __and__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __bool__(self) -> 'bool'
     |  
     |  __complex__(self) -> 'complex'
     |  
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  __float__(self) -> 'float'
     |  
     |  __ge__(self, other: 'Any') -> 'bool'
     |      Return self>=value.
     |  
     |  __gt__(self, other: 'Any') -> 'bool'
     |      Return self>value.
     |  
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |  
     |  __int__(self) -> 'int'
     |  
     |  __invert__(self) -> 'Not'
     |  
     |  __le__(self, other: 'Any') -> 'bool'
     |      Return self<=value.
     |  
     |  __lt__(self, other: 'Any') -> 'bool'
     |      Return self<value.
     |  
     |  __mul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ne__(self, other: 'Any') -> 'bool'
     |      Return self!=value.
     |  
     |  __neg__(self) -> 'Negate'
     |  
     |  __or__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __pow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __radd__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __rand__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __rmul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ror__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __rpow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __rsub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rtruediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rxor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  __setattr__(self, key: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  __sub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __truediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __xor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  display(self) -> 'None'
     |      shows graphical representation of expression
     |  
     |  total_derivative(self) -> 'Node'
     |      returns an expression tree representing the total derivative of this tree.
     |      the total derivative of f is defined as sum(f.derivative(var) for var in f.dependencies)
    
    class Term(Node)
     |  Term() -> 'None'
     |  
     |  Abstract Base Class for any value (leaf node) in the expression tree
     |  
     |  Method resolution order:
     |      Term
     |      Node
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  list_nodes(self) -> 'list[Node]'
     |      returns a list of all nodes in the tree
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset({'__repr__', 'derivative', 'evaluate',...
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Node:
     |  
     |  __add__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __and__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __bool__(self) -> 'bool'
     |  
     |  __complex__(self) -> 'complex'
     |  
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  __float__(self) -> 'float'
     |  
     |  __ge__(self, other: 'Any') -> 'bool'
     |      Return self>=value.
     |  
     |  __gt__(self, other: 'Any') -> 'bool'
     |      Return self>value.
     |  
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |  
     |  __init__(self) -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __int__(self) -> 'int'
     |  
     |  __invert__(self) -> 'Not'
     |  
     |  __le__(self, other: 'Any') -> 'bool'
     |      Return self<=value.
     |  
     |  __lt__(self, other: 'Any') -> 'bool'
     |      Return self<value.
     |  
     |  __mul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ne__(self, other: 'Any') -> 'bool'
     |      Return self!=value.
     |  
     |  __neg__(self) -> 'Negate'
     |  
     |  __or__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __pow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __radd__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __rand__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  __rmul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ror__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __rpow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __rsub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rtruediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rxor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  __setattr__(self, key: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  __sub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __truediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __xor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  dependencies(self) -> 'set[str]'
     |      returns set of all variables present in the tree
     |  
     |  derivative(self, variable: 'str') -> 'Node'
     |      returns an expression tree representing the (partial) derivative to the passed variable of this tree
     |  
     |  display(self) -> 'None'
     |      shows graphical representation of expression
     |  
     |  evaluate(self, var_dict: 'Optional[Variables]' = None) -> 'ConstantType'
     |      Evaluates the expression tree using the values from var_dict, returns int or float
     |  
     |  infix(self) -> 'str'
     |      returns infix representation of the tree
     |  
     |  mathml(self) -> 'str'
     |      returns the MathML representation of the tree
     |  
     |  simplify(self, var_dict: 'Optional[Variables]' = None) -> 'Node'
     |      returns a simplified version of the tree
     |  
     |  substitute(self, var: 'str', sub: 'Node') -> 'Node'
     |      substitute a variable with an expression inside this tree, returns the resulting tree
     |  
     |  total_derivative(self) -> 'Node'
     |      returns an expression tree representing the total derivative of this tree.
     |      the total derivative of f is defined as sum(f.derivative(var) for var in f.dependencies)
     |  
     |  wolfram(self) -> 'str'
     |      return wolfram language representation of the tree
    
    class UnaryOperator(Node)
     |  UnaryOperator(child: 'Node') -> 'None'
     |  
     |  Abstract Base Class for single-input operator in expression tree
     |  
     |  Method resolution order:
     |      UnaryOperator
     |      Node
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, child: 'Node') -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  dependencies(self) -> 'set[str]'
     |      returns set of all variables present in the tree
     |  
     |  infix(self) -> 'str'
     |      returns infix representation of the tree
     |  
     |  list_nodes(self) -> 'list[Node]'
     |      returns a list of all nodes in the tree
     |  
     |  mathml(self) -> 'str'
     |      returns the MathML representation of the tree
     |  
     |  simplify(self, var_dict: 'Optional[Variables]' = None) -> 'Node'
     |      returns a simplified version of the tree
     |  
     |  substitute(self, var: 'str', sub: 'Node') -> 'Node'
     |      substitute a variable with an expression inside this tree, returns the resulting tree
     |  
     |  wolfram(self) -> 'str'
     |      return wolfram language representation of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  child
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset({'derivative', 'evaluate'})
     |  
     |  symbol = ''
     |  
     |  wolfram_func = ''
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Node:
     |  
     |  __add__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __and__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __bool__(self) -> 'bool'
     |  
     |  __complex__(self) -> 'complex'
     |  
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  __float__(self) -> 'float'
     |  
     |  __ge__(self, other: 'Any') -> 'bool'
     |      Return self>=value.
     |  
     |  __gt__(self, other: 'Any') -> 'bool'
     |      Return self>value.
     |  
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |  
     |  __int__(self) -> 'int'
     |  
     |  __invert__(self) -> 'Not'
     |  
     |  __le__(self, other: 'Any') -> 'bool'
     |      Return self<=value.
     |  
     |  __lt__(self, other: 'Any') -> 'bool'
     |      Return self<value.
     |  
     |  __mul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ne__(self, other: 'Any') -> 'bool'
     |      Return self!=value.
     |  
     |  __neg__(self) -> 'Negate'
     |  
     |  __or__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __pow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __radd__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __rand__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __rmul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ror__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __rpow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __rsub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rtruediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rxor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  __setattr__(self, key: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  __sub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __truediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __xor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  derivative(self, variable: 'str') -> 'Node'
     |      returns an expression tree representing the (partial) derivative to the passed variable of this tree
     |  
     |  display(self) -> 'None'
     |      shows graphical representation of expression
     |  
     |  evaluate(self, var_dict: 'Optional[Variables]' = None) -> 'ConstantType'
     |      Evaluates the expression tree using the values from var_dict, returns int or float
     |  
     |  total_derivative(self) -> 'Node'
     |      returns an expression tree representing the total derivative of this tree.
     |      the total derivative of f is defined as sum(f.derivative(var) for var in f.dependencies)
    
    class Variable(Term)
     |  Variable(value: 'str') -> 'None'
     |  
     |  Named variable in expression tree
     |  
     |  Method resolution order:
     |      Variable
     |      Term
     |      Node
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, value: 'str') -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  dependencies(self) -> 'set[str]'
     |      returns set of all variables present in the tree
     |  
     |  derivative(self, variable: 'str') -> 'Node'
     |      returns an expression tree representing the (partial) derivative to the passed variable of this tree
     |  
     |  evaluate(self, var_dict: 'Optional[Variables]' = None) -> 'ConstantType'
     |      Evaluates the expression tree using the values from var_dict, returns int or float
     |  
     |  infix(self) -> 'str'
     |      returns infix representation of the tree
     |  
     |  mathml(self) -> 'str'
     |      returns the MathML representation of the tree
     |  
     |  simplify(self, var_dict: 'Optional[Variables]' = None) -> 'Node'
     |      returns a simplified version of the tree
     |  
     |  substitute(self, var: 'str', sub: 'Node') -> 'Node'
     |      substitute a variable with an expression inside this tree, returns the resulting tree
     |  
     |  wolfram(self) -> 'str'
     |      return wolfram language representation of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  name
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Term:
     |  
     |  list_nodes(self) -> 'list[Node]'
     |      returns a list of all nodes in the tree
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Node:
     |  
     |  __add__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __and__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __bool__(self) -> 'bool'
     |  
     |  __complex__(self) -> 'complex'
     |  
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  __float__(self) -> 'float'
     |  
     |  __ge__(self, other: 'Any') -> 'bool'
     |      Return self>=value.
     |  
     |  __gt__(self, other: 'Any') -> 'bool'
     |      Return self>value.
     |  
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |  
     |  __int__(self) -> 'int'
     |  
     |  __invert__(self) -> 'Not'
     |  
     |  __le__(self, other: 'Any') -> 'bool'
     |      Return self<=value.
     |  
     |  __lt__(self, other: 'Any') -> 'bool'
     |      Return self<value.
     |  
     |  __mul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ne__(self, other: 'Any') -> 'bool'
     |      Return self!=value.
     |  
     |  __neg__(self) -> 'Negate'
     |  
     |  __or__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __pow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __radd__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __rand__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __rmul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ror__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __rpow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __rsub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rtruediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rxor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  __setattr__(self, key: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  __sub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __truediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __xor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  display(self) -> 'None'
     |      shows graphical representation of expression
     |  
     |  total_derivative(self) -> 'Node'
     |      returns an expression tree representing the total derivative of this tree.
     |      the total derivative of f is defined as sum(f.derivative(var) for var in f.dependencies)
    
    class Xor(ArbitraryLogicalOperator)
     |  Xor(*args: 'Node') -> 'None'
     |  
     |  logical XOR operator node
     |  
     |  Method resolution order:
     |      Xor
     |      ArbitraryLogicalOperator
     |      ArbitraryOperator
     |      Node
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  symbol = '^'
     |  
     |  wolfram_func = 'Xor'
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ArbitraryLogicalOperator:
     |  
     |  derivative(self, variable: 'str') -> 'Node'
     |      returns an expression tree representing the (partial) derivative to the passed variable of this tree
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from ArbitraryOperator:
     |  
     |  __init__(self, *args: 'Node') -> 'None'
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self) -> 'str'
     |      Return repr(self).
     |  
     |  dependencies(self) -> 'set[str]'
     |      returns set of all variables present in the tree
     |  
     |  evaluate(self, var_dict: 'Optional[Variables]' = None) -> 'ConstantType'
     |      Evaluates the expression tree using the values from var_dict, returns int or float
     |  
     |  infix(self) -> 'str'
     |      returns infix representation of the tree
     |  
     |  list_nodes(self) -> 'list[Node]'
     |      returns a list of all nodes in the tree
     |  
     |  mathml(self) -> 'str'
     |      returns the MathML representation of the tree
     |  
     |  simplify(self, var_dict: 'Optional[Variables]' = None) -> 'Node'
     |      returns a simplified version of the tree
     |  
     |  substitute(self, var: 'str', sub: 'Node') -> 'Node'
     |      substitute a variable with an expression inside this tree, returns the resulting tree
     |  
     |  wolfram(self) -> 'str'
     |      return wolfram language representation of the tree
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from ArbitraryOperator:
     |  
     |  children
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Node:
     |  
     |  __add__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __and__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __bool__(self) -> 'bool'
     |  
     |  __complex__(self) -> 'complex'
     |  
     |  __eq__(self, other: 'Any') -> 'bool'
     |      Return self==value.
     |  
     |  __float__(self) -> 'float'
     |  
     |  __ge__(self, other: 'Any') -> 'bool'
     |      Return self>=value.
     |  
     |  __gt__(self, other: 'Any') -> 'bool'
     |      Return self>value.
     |  
     |  __hash__(self) -> 'int'
     |      Return hash(self).
     |  
     |  __int__(self) -> 'int'
     |  
     |  __invert__(self) -> 'Not'
     |  
     |  __le__(self, other: 'Any') -> 'bool'
     |      Return self<=value.
     |  
     |  __lt__(self, other: 'Any') -> 'bool'
     |      Return self<value.
     |  
     |  __mul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ne__(self, other: 'Any') -> 'bool'
     |      Return self!=value.
     |  
     |  __neg__(self) -> 'Negate'
     |  
     |  __or__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __pow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __radd__(self, other: 'Union[Node, ConstantType, str]') -> 'Sum'
     |  
     |  __rand__(self, other: 'Union[Node, ConstantType, str]') -> 'And'
     |  
     |  __rmul__(self, other: 'Union[Node, ConstantType, str]') -> 'Product'
     |  
     |  __ror__(self, other: 'Union[Node, ConstantType, str]') -> 'Or'
     |  
     |  __rpow__(self, other: 'Union[Node, ConstantType, str]') -> 'Exponent'
     |  
     |  __rsub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rtruediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __rxor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  __setattr__(self, key: 'str', value: 'Any') -> 'None'
     |      Implement setattr(self, name, value).
     |  
     |  __str__(self) -> 'str'
     |      Return str(self).
     |  
     |  __sub__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __truediv__(self, other: 'Union[Node, ConstantType, str]') -> 'Node'
     |  
     |  __xor__(self, other: 'Union[Node, ConstantType, str]') -> 'Xor'
     |  
     |  display(self) -> 'None'
     |      shows graphical representation of expression
     |  
     |  total_derivative(self) -> 'Node'
     |      returns an expression tree representing the total derivative of this tree.
     |      the total derivative of f is defined as sum(f.derivative(var) for var in f.dependencies)

FUNCTIONS
    Division(*args: 'Node') -> 'Node'
        Division operator node
    
    Nand(*args: 'Node') -> 'Not'
        logical NAND operator node
    
    Nodeify(other: 'Union[Node, ConstantType, str]') -> 'Node'
        turn given input into constant or variable leaf node
    
    Nor(*args: 'Node') -> 'Not'
        logical NOR operator node
    
    NotEqual(*args: 'Node') -> 'Node'
        Inequality operator node
    
    Subtraction(*args: 'Node') -> 'Node'
        Subtraction operator node
    
    Xnor(*args: 'Node') -> 'Not'
        logical XNOR operator node
    
    acos(x, /)
        Return the arc cosine (measured in radians) of x.
        
        The result is between 0 and pi.
    
    asin(x, /)
        Return the arc sine (measured in radians) of x.
        
        The result is between -pi/2 and pi/2.
    
    atan(x, /)
        Return the arc tangent (measured in radians) of x.
        
        The result is between -pi/2 and pi/2.
    
    ceil(x, /)
        Return the ceiling of x as an Integral.
        
        This is the smallest integer >= x.
    
    cos(x, /)
        Return the cosine of x (measured in radians).
    
    display(expression: 'Node') -> 'None'
        Generates and opens html representation of expression
    
    factorial(x, /)
        Find x!.
        
        Raise a ValueError if x is negative or non-integral.
    
    floor(x, /)
        Return the floor of x as an Integral.
        
        This is the largest integer <= x.
    
    gamma(x, /)
        Gamma function at x.
    
    generate_html_code(expression: 'Node') -> 'str'
        generates html code for expression
    
    generate_html_doc(expression: 'Node') -> 'None'
        generates html document for expression
    
    isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0)
        Determine whether two floating point numbers are close in value.
        
          rel_tol
            maximum difference for being considered "close", relative to the
            magnitude of the input values
          abs_tol
            maximum difference for being considered "close", regardless of the
            magnitude of the input values
        
        Return True if a is close in value to b, and False otherwise.
        
        For the values to be considered close, the difference between them
        must be smaller than at least one of the tolerances.
        
        -inf, inf and NaN behave similarly to the IEEE 754 Standard.  That
        is, NaN is not close to anything, even itself.  inf and -inf are
        only close to themselves.
    
    log(...)
        log(x, [base=math.e])
        Return the logarithm of x to the given base.
        
        If the base not specified, returns the natural logarithm (base e) of x.
    
    mathml_tag(xml_tag: 'str', content: 'str', args: 'Optional[str]' = None) -> 'str'
        Mathml tag wrapping function
    
    reduce(...)
        reduce(function, sequence[, initial]) -> value
        
        Apply a function of two arguments cumulatively to the items of a sequence,
        from left to right, so as to reduce the sequence to a single value.
        For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates
        ((((1+2)+3)+4)+5).  If initial is present, it is placed before the items
        of the sequence in the calculation, and serves as a default when the
        sequence is empty.
    
    sin(x, /)
        Return the sine of x (measured in radians).
    
    tag(xml_tag: 'str', content: 'str', args: 'Optional[str]' = None) -> 'str'
        XML tag wrapping function
    
    tan(x, /)
        Return the tangent of x (measured in radians).

DATA
    Any = typing.Any
        Special type indicating an unconstrained type.
        
        - Any is compatible with every type.
        - Any assumed to have all methods.
        - All values assumed to be instances of Any.
        
        Note that all the above statements are true from the point of view of
        static type checkers. At runtime, Any should not be used with instance
        or class checks.
    
    ConstantType = typing.Union[int, fractions.Fraction, float, complex, b...
    Optional = typing.Optional
        Optional type.
        
        Optional[X] is equivalent to Union[X, None].
    
    Union = typing.Union
        Union type; Union[X, Y] means either X or Y.
        
        To define a union, use e.g. Union[int, str].  Details:
        - The arguments must be types and there must be at least one.
        - None as an argument is a special case and is replaced by
          type(None).
        - Unions of unions are flattened, e.g.::
        
            Union[Union[int, str], float] == Union[int, str, float]
        
        - Unions of a single argument vanish, e.g.::
        
            Union[int] == int  # The constructor actually returns int
        
        - Redundant arguments are skipped, e.g.::
        
            Union[int, str, int] == Union[int, str]
        
        - When comparing unions, the argument order is ignored, e.g.::
        
            Union[int, str] == Union[str, int]
        
        - You cannot subclass or instantiate a union.
        - You can use Optional[X] as a shorthand for Union[X, None].
    
    annotations = _Feature((3, 7, 0, 'beta', 1), (3, 10, 0, 'alpha', 0), 1...
    e = 2.718281828459045
    pi = 3.141592653589793

FILE
    c:\users\twan\documents\python\python_algebra\math_tree.py


